{"ast":null,"code":"import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { map } from '../operators/map';\nimport { isObject } from '../util/isObject';\nimport { from } from './from';\nexport function forkJoin(...sources) {\n  if (sources.length === 1) {\n    const first = sources[0];\n    if (isArray(first)) {\n      return forkJoinInternal(first, null);\n    }\n    if (isObject(first) && Object.getPrototypeOf(first) === Object.prototype) {\n      const keys = Object.keys(first);\n      return forkJoinInternal(keys.map(key => first[key]), keys);\n    }\n  }\n  if (typeof sources[sources.length - 1] === 'function') {\n    const resultSelector = sources.pop();\n    sources = sources.length === 1 && isArray(sources[0]) ? sources[0] : sources;\n    return forkJoinInternal(sources, null).pipe(map(args => resultSelector(...args)));\n  }\n  return forkJoinInternal(sources, null);\n}\nfunction forkJoinInternal(sources, keys) {\n  return new Observable(subscriber => {\n    const len = sources.length;\n    if (len === 0) {\n      subscriber.complete();\n      return;\n    }\n    const values = new Array(len);\n    let completed = 0;\n    let emitted = 0;\n    for (let i = 0; i < len; i++) {\n      const source = from(sources[i]);\n      let hasValue = false;\n      subscriber.add(source.subscribe({\n        next: value => {\n          if (!hasValue) {\n            hasValue = true;\n            emitted++;\n          }\n          values[i] = value;\n        },\n        error: err => subscriber.error(err),\n        complete: () => {\n          completed++;\n          if (completed === len || !hasValue) {\n            if (emitted === len) {\n              subscriber.next(keys ? keys.reduce((result, key, i) => (result[key] = values[i], result), {}) : values);\n            }\n            subscriber.complete();\n          }\n        }\n      }));\n    }\n  });\n}","map":{"version":3,"names":["Observable","isArray","map","isObject","from","forkJoin","sources","length","first","forkJoinInternal","Object","getPrototypeOf","prototype","keys","key","resultSelector","pop","pipe","args","subscriber","len","complete","values","Array","completed","emitted","i","source","hasValue","add","subscribe","next","value","error","err","reduce","result"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\observable\\forkJoin.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { ObservableInput, ObservedValuesFromArray, ObservedValueOf, SubscribableOrPromise } from '../types';\nimport { isArray } from '../util/isArray';\nimport { map } from '../operators/map';\nimport { isObject } from '../util/isObject';\nimport { isObservable } from '../util/isObservable';\nimport { from } from './from';\n\n/* tslint:disable:max-line-length */\n\n// forkJoin(a$, b$, c$)\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T>(v1: SubscribableOrPromise<T>): Observable<[T]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\n\n// forkJoin([a$, b$, c$]);\n// TODO(benlesh): Uncomment for TS 3.0\n// export function forkJoin(sources: []): Observable<never>;\nexport function forkJoin<A>(sources: [ObservableInput<A>]): Observable<[A]>;\nexport function forkJoin<A, B>(sources: [ObservableInput<A>, ObservableInput<B>]): Observable<[A, B]>;\nexport function forkJoin<A, B, C>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>]): Observable<[A, B, C]>;\nexport function forkJoin<A, B, C, D>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>]): Observable<[A, B, C, D]>;\nexport function forkJoin<A, B, C, D, E>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>, ObservableInput<E>]): Observable<[A, B, C, D, E]>;\nexport function forkJoin<A, B, C, D, E, F>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>, ObservableInput<E>, ObservableInput<F>]): Observable<[A, B, C, D, E, F]>;\nexport function forkJoin<A extends ObservableInput<any>[]>(sources: A): Observable<ObservedValuesFromArray<A>[]>;\n\n// forkJoin({})\nexport function forkJoin(sourcesObject: {}): Observable<never>;\nexport function forkJoin<T, K extends keyof T>(sourcesObject: T): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\n\n/** @deprecated resultSelector is deprecated, pipe to map instead */\nexport function forkJoin(...args: Array<ObservableInput<any>|Function>): Observable<any>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport function forkJoin<T>(...sources: ObservableInput<T>[]): Observable<T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Accepts an `Array` of {@link ObservableInput} or a dictionary `Object` of {@link ObservableInput} and returns\n * an {@link Observable} that emits either an array of values in the exact same order as the passed array,\n * or a dictionary of values in the same shape as the passed dictionary.\n *\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n *\n * ![](forkJoin.png)\n *\n * `forkJoin` is an operator that takes any number of input observables which can be passed either as an array\n * or a dictionary of input observables. If no input observables are provided, resulting stream will complete\n * immediately.\n *\n * `forkJoin` will wait for all passed observables to complete and then it will emit an array or an object with last\n * values from corresponding observables.\n *\n * If you pass an array of `n` observables to the operator, resulting\n * array will have `n` values, where first value is the last thing emitted by the first observable,\n * second value is the last thing emitted by the second observable and so on.\n *\n * If you pass a dictionary of observables to the operator, resulting\n * objects will have the same keys as the dictionary passed, with their last values they've emitted\n * located at the corresponding key.\n *\n * That means `forkJoin` will not emit more than once and it will complete after that. If you need to emit combined\n * values not only at the end of lifecycle of passed observables, but also throughout it, try out {@link combineLatest}\n * or {@link zip} instead.\n *\n * In order for resulting array to have the same length as the number of input observables, whenever any of\n * that observables completes without emitting any value, `forkJoin` will complete at that moment as well\n * and it will not emit anything either, even if it already has some last values from other observables.\n * Conversely, if there is an observable that never completes, `forkJoin` will never complete as well,\n * unless at any point some other observable completes without emitting value, which brings us back to\n * the previous case. Overall, in order for `forkJoin` to emit a value, all observables passed as arguments\n * have to emit something at least once and complete.\n *\n * If any input observable errors at some point, `forkJoin` will error as well and all other observables\n * will be immediately unsubscribed.\n *\n * Optionally `forkJoin` accepts project function, that will be called with values which normally\n * would land in emitted array. Whatever is returned by project function, will appear in output\n * observable instead. This means that default project can be thought of as a function that takes\n * all its arguments and puts them into an array. Note that project function will be called only\n * when output observable is supposed to emit a result.\n *\n * ## Examples\n *\n * ### Use forkJoin with a dictionary of observable inputs\n * ```ts\n * import { forkJoin, of, timer } from 'rxjs';\n *\n * const observable = forkJoin({\n *   foo: of(1, 2, 3, 4),\n *   bar: Promise.resolve(8),\n *   baz: timer(4000),\n * });\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // { foo: 4, bar: 8, baz: 0 } after 4 seconds\n * // \"This is how it ends!\" immediately after\n * ```\n *\n * ### Use forkJoin with an array of observable inputs\n * ```ts\n * import { forkJoin, of } from 'rxjs';\n *\n * const observable = forkJoin([\n *   of(1, 2, 3, 4),\n *   Promise.resolve(8),\n *   timer(4000),\n * ]);\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // [4, 8, 0] after 4 seconds\n * // \"This is how it ends!\" immediately after\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n *\n * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments\n * passed directly to the operator.\n * @param {function} [project] Function that takes values emitted by input Observables and returns value\n * that will appear in resulting Observable instead of default array.\n * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n * or value from project function.\n */\nexport function forkJoin(\n  ...sources: any[]\n): Observable<any> {\n  if (sources.length === 1) {\n    const first = sources[0];\n    if (isArray(first)) {\n      return forkJoinInternal(first, null);\n    }\n    // TODO(benlesh): isObservable check will not be necessary when deprecated path is removed.\n    if (isObject(first) && Object.getPrototypeOf(first) === Object.prototype) {\n      const keys = Object.keys(first);\n      return forkJoinInternal(keys.map(key => first[key]), keys);\n    }\n  }\n\n  // DEPRECATED PATHS BELOW HERE\n  if (typeof sources[sources.length - 1] === 'function') {\n    const resultSelector = sources.pop() as Function;\n    sources = (sources.length === 1 && isArray(sources[0])) ? sources[0] : sources;\n    return forkJoinInternal(sources, null).pipe(\n      map((args: any[]) => resultSelector(...args))\n    );\n  }\n\n  return forkJoinInternal(sources, null);\n}\n\nfunction forkJoinInternal(sources: ObservableInput<any>[], keys: string[] | null): Observable<any> {\n  return new Observable(subscriber => {\n    const len = sources.length;\n    if (len === 0) {\n      subscriber.complete();\n      return;\n    }\n    const values = new Array(len);\n    let completed = 0;\n    let emitted = 0;\n    for (let i = 0; i < len; i++) {\n      const source = from(sources[i]);\n      let hasValue = false;\n      subscriber.add(source.subscribe({\n        next: value => {\n          if (!hasValue) {\n            hasValue = true;\n            emitted++;\n          }\n          values[i] = value;\n        },\n        error: err => subscriber.error(err),\n        complete: () => {\n          completed++;\n          if (completed === len || !hasValue) {\n            if (emitted === len) {\n              subscriber.next(keys ?\n                keys.reduce((result, key, i) => (result[key] = values[i], result), {}) :\n                values);\n            }\n            subscriber.complete();\n          }\n        }\n      }));\n    }\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}