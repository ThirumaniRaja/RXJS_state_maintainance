{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nexport function skipLast(count) {\n  return source => source.lift(new SkipLastOperator(count));\n}\nclass SkipLastOperator {\n  constructor(_skipCount) {\n    this._skipCount = _skipCount;\n    if (this._skipCount < 0) {\n      throw new ArgumentOutOfRangeError();\n    }\n  }\n  call(subscriber, source) {\n    if (this._skipCount === 0) {\n      return source.subscribe(new Subscriber(subscriber));\n    } else {\n      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n    }\n  }\n}\nclass SkipLastSubscriber extends Subscriber {\n  constructor(destination, _skipCount) {\n    super(destination);\n    this._skipCount = _skipCount;\n    this._count = 0;\n    this._ring = new Array(_skipCount);\n  }\n  _next(value) {\n    const skipCount = this._skipCount;\n    const count = this._count++;\n    if (count < skipCount) {\n      this._ring[count] = value;\n    } else {\n      const currentIndex = count % skipCount;\n      const ring = this._ring;\n      const oldValue = ring[currentIndex];\n      ring[currentIndex] = value;\n      this.destination.next(oldValue);\n    }\n  }\n}","map":{"version":3,"names":["Subscriber","ArgumentOutOfRangeError","skipLast","count","source","lift","SkipLastOperator","constructor","_skipCount","call","subscriber","subscribe","SkipLastSubscriber","destination","_count","_ring","Array","_next","value","skipCount","currentIndex","ring","oldValue","next"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\skipLast.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * ![](skipLast.png)\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * ## Example\n * Skip the last 2 values of an Observable with many values\n * ```ts\n * import { range } from 'rxjs';\n * import { skipLast } from 'rxjs/operators';\n *\n * const many = range(1, 5);\n * const skipLastTwo = many.pipe(skipLast(2));\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nexport function skipLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipLastOperator(count));\n}\n\nclass SkipLastOperator<T> implements Operator<T, T> {\n  constructor(private _skipCount: number) {\n    if (this._skipCount < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    if (this._skipCount === 0) {\n      // If we don't want to skip any values then just subscribe\n      // to Subscriber without any further logic.\n      return source.subscribe(new Subscriber(subscriber));\n    } else {\n      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipLastSubscriber<T> extends Subscriber<T> {\n  private _ring: T[];\n  private _count: number = 0;\n\n  constructor(destination: Subscriber<T>, private _skipCount: number) {\n    super(destination);\n    this._ring = new Array<T>(_skipCount);\n  }\n\n  protected _next(value: T): void {\n    const skipCount = this._skipCount;\n    const count = this._count++;\n\n    if (count < skipCount) {\n      this._ring[count] = value;\n    } else {\n      const currentIndex = count % skipCount;\n      const ring = this._ring;\n      const oldValue = ring[currentIndex];\n\n      ring[currentIndex] = value;\n      this.destination.next(oldValue);\n    }\n  }\n}\n"],"mappings":"AACA,SAASA,UAAU,QAAQ,eAAe;AAC1C,SAASC,uBAAuB,QAAQ,iCAAiC;AA0CzE,OAAM,SAAUC,QAAQA,CAAIC,KAAa;EACvC,OAAQC,MAAqB,IAAKA,MAAM,CAACC,IAAI,CAAC,IAAIC,gBAAgB,CAACH,KAAK,CAAC,CAAC;AAC5E;AAEA,MAAMG,gBAAgB;EACpBC,YAAoBC,UAAkB;IAAlB,KAAAA,UAAU,GAAVA,UAAU;IAC5B,IAAI,IAAI,CAACA,UAAU,GAAG,CAAC,EAAE;MACvB,MAAM,IAAIP,uBAAuB,CAAvB,CAAuB;;EAErC;EAEAQ,IAAIA,CAACC,UAAyB,EAAEN,MAAW;IACzC,IAAI,IAAI,CAACI,UAAU,KAAK,CAAC,EAAE;MAGzB,OAAOJ,MAAM,CAACO,SAAS,CAAC,IAAIX,UAAU,CAACU,UAAU,CAAC,CAAC;KACpD,MAAM;MACL,OAAON,MAAM,CAACO,SAAS,CAAC,IAAIC,kBAAkB,CAACF,UAAU,EAAE,IAAI,CAACF,UAAU,CAAC,CAAC;;EAEhF;;AAQF,MAAMI,kBAAsB,SAAQZ,UAAa;EAI/CO,YAAYM,WAA0B,EAAUL,UAAkB;IAChE,KAAK,CAACK,WAAW,CAAC;IAD4B,KAAAL,UAAU,GAAVA,UAAU;IAFlD,KAAAM,MAAM,GAAW,CAAC;IAIxB,IAAI,CAACC,KAAK,GAAG,IAAIC,KAAK,CAAIR,UAAU,CAAC;EACvC;EAEUS,KAAKA,CAACC,KAAQ;IACtB,MAAMC,SAAS,GAAG,IAAI,CAACX,UAAU;IACjC,MAAML,KAAK,GAAG,IAAI,CAACW,MAAM,EAAE;IAE3B,IAAIX,KAAK,GAAGgB,SAAS,EAAE;MACrB,IAAI,CAACJ,KAAK,CAACZ,KAAK,CAAC,GAAGe,KAAK;KAC1B,MAAM;MACL,MAAME,YAAY,GAAGjB,KAAK,GAAGgB,SAAS;MACtC,MAAME,IAAI,GAAG,IAAI,CAACN,KAAK;MACvB,MAAMO,QAAQ,GAAGD,IAAI,CAACD,YAAY,CAAC;MAEnCC,IAAI,CAACD,YAAY,CAAC,GAAGF,KAAK;MAC1B,IAAI,CAACL,WAAW,CAACU,IAAI,CAACD,QAAQ,CAAC;;EAEnC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}