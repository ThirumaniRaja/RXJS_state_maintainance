{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nexport function mapTo(value) {\n  return source => source.lift(new MapToOperator(value));\n}\nclass MapToOperator {\n  constructor(value) {\n    this.value = value;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new MapToSubscriber(subscriber, this.value));\n  }\n}\nclass MapToSubscriber extends Subscriber {\n  constructor(destination, value) {\n    super(destination);\n    this.value = value;\n  }\n  _next(x) {\n    this.destination.next(this.value);\n  }\n}","map":{"version":3,"names":["Subscriber","mapTo","value","source","lift","MapToOperator","constructor","call","subscriber","subscribe","MapToSubscriber","destination","_next","x","next"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\mapTo.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * ![](mapTo.png)\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * ## Example\n * Map every click to the string 'Hi'\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { mapTo } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const greetings = clicks.pipe(mapTo('Hi'));\n * greetings.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new MapToOperator(value));\n}\n\nclass MapToOperator<T, R> implements Operator<T, R> {\n\n  value: R;\n\n  constructor(value: R) {\n    this.value = value;\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapToSubscriber(subscriber, this.value));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapToSubscriber<T, R> extends Subscriber<T> {\n\n  value: R;\n\n  constructor(destination: Subscriber<R>, value: R) {\n    super(destination);\n    this.value = value;\n  }\n\n  protected _next(x: T) {\n    this.destination.next(this.value);\n  }\n}\n"],"mappings":"AACA,SAASA,UAAU,QAAQ,eAAe;AAoC1C,OAAM,SAAUC,KAAKA,CAAOC,KAAQ;EAClC,OAAQC,MAAqB,IAAKA,MAAM,CAACC,IAAI,CAAC,IAAIC,aAAa,CAACH,KAAK,CAAC,CAAC;AACzE;AAEA,MAAMG,aAAa;EAIjBC,YAAYJ,KAAQ;IAClB,IAAI,CAACA,KAAK,GAAGA,KAAK;EACpB;EAEAK,IAAIA,CAACC,UAAyB,EAAEL,MAAW;IACzC,OAAOA,MAAM,CAACM,SAAS,CAAC,IAAIC,eAAe,CAACF,UAAU,EAAE,IAAI,CAACN,KAAK,CAAC,CAAC;EACtE;;AAQF,MAAMQ,eAAsB,SAAQV,UAAa;EAI/CM,YAAYK,WAA0B,EAAET,KAAQ;IAC9C,KAAK,CAACS,WAAW,CAAC;IAClB,IAAI,CAACT,KAAK,GAAGA,KAAK;EACpB;EAEUU,KAAKA,CAACC,CAAI;IAClB,IAAI,CAACF,WAAW,CAACG,IAAI,CAAC,IAAI,CAACZ,KAAK,CAAC;EACnC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}