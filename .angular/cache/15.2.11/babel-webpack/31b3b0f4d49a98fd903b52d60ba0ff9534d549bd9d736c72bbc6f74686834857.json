{"ast":null,"code":"import { fromArray } from './fromArray';\nimport { isArray } from '../util/isArray';\nimport { Subscriber } from '../Subscriber';\nimport { iterator as Symbol_iterator } from '../../internal/symbol/iterator';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\nexport function zip(...observables) {\n  const resultSelector = observables[observables.length - 1];\n  if (typeof resultSelector === 'function') {\n    observables.pop();\n  }\n  return fromArray(observables, undefined).lift(new ZipOperator(resultSelector));\n}\nexport class ZipOperator {\n  constructor(resultSelector) {\n    this.resultSelector = resultSelector;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));\n  }\n}\nexport class ZipSubscriber extends Subscriber {\n  constructor(destination, resultSelector, values = Object.create(null)) {\n    super(destination);\n    this.resultSelector = resultSelector;\n    this.iterators = [];\n    this.active = 0;\n    this.resultSelector = typeof resultSelector === 'function' ? resultSelector : undefined;\n  }\n  _next(value) {\n    const iterators = this.iterators;\n    if (isArray(value)) {\n      iterators.push(new StaticArrayIterator(value));\n    } else if (typeof value[Symbol_iterator] === 'function') {\n      iterators.push(new StaticIterator(value[Symbol_iterator]()));\n    } else {\n      iterators.push(new ZipBufferIterator(this.destination, this, value));\n    }\n  }\n  _complete() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n    this.unsubscribe();\n    if (len === 0) {\n      this.destination.complete();\n      return;\n    }\n    this.active = len;\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      if (iterator.stillUnsubscribed) {\n        const destination = this.destination;\n        destination.add(iterator.subscribe());\n      } else {\n        this.active--;\n      }\n    }\n  }\n  notifyInactive() {\n    this.active--;\n    if (this.active === 0) {\n      this.destination.complete();\n    }\n  }\n  checkIterators() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n    const destination = this.destination;\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n        return;\n      }\n    }\n    let shouldComplete = false;\n    const args = [];\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      let result = iterator.next();\n      if (iterator.hasCompleted()) {\n        shouldComplete = true;\n      }\n      if (result.done) {\n        destination.complete();\n        return;\n      }\n      args.push(result.value);\n    }\n    if (this.resultSelector) {\n      this._tryresultSelector(args);\n    } else {\n      destination.next(args);\n    }\n    if (shouldComplete) {\n      destination.complete();\n    }\n  }\n  _tryresultSelector(args) {\n    let result;\n    try {\n      result = this.resultSelector.apply(this, args);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\nclass StaticIterator {\n  constructor(iterator) {\n    this.iterator = iterator;\n    this.nextResult = iterator.next();\n  }\n  hasValue() {\n    return true;\n  }\n  next() {\n    const result = this.nextResult;\n    this.nextResult = this.iterator.next();\n    return result;\n  }\n  hasCompleted() {\n    const nextResult = this.nextResult;\n    return Boolean(nextResult && nextResult.done);\n  }\n}\nclass StaticArrayIterator {\n  constructor(array) {\n    this.array = array;\n    this.index = 0;\n    this.length = 0;\n    this.length = array.length;\n  }\n  [Symbol_iterator]() {\n    return this;\n  }\n  next(value) {\n    const i = this.index++;\n    const array = this.array;\n    return i < this.length ? {\n      value: array[i],\n      done: false\n    } : {\n      value: null,\n      done: true\n    };\n  }\n  hasValue() {\n    return this.array.length > this.index;\n  }\n  hasCompleted() {\n    return this.array.length === this.index;\n  }\n}\nclass ZipBufferIterator extends SimpleOuterSubscriber {\n  constructor(destination, parent, observable) {\n    super(destination);\n    this.parent = parent;\n    this.observable = observable;\n    this.stillUnsubscribed = true;\n    this.buffer = [];\n    this.isComplete = false;\n  }\n  [Symbol_iterator]() {\n    return this;\n  }\n  next() {\n    const buffer = this.buffer;\n    if (buffer.length === 0 && this.isComplete) {\n      return {\n        value: null,\n        done: true\n      };\n    } else {\n      return {\n        value: buffer.shift(),\n        done: false\n      };\n    }\n  }\n  hasValue() {\n    return this.buffer.length > 0;\n  }\n  hasCompleted() {\n    return this.buffer.length === 0 && this.isComplete;\n  }\n  notifyComplete() {\n    if (this.buffer.length > 0) {\n      this.isComplete = true;\n      this.parent.notifyInactive();\n    } else {\n      this.destination.complete();\n    }\n  }\n  notifyNext(innerValue) {\n    this.buffer.push(innerValue);\n    this.parent.checkIterators();\n  }\n  subscribe() {\n    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));\n  }\n}","map":{"version":3,"names":["fromArray","isArray","Subscriber","iterator","Symbol_iterator","SimpleOuterSubscriber","SimpleInnerSubscriber","innerSubscribe","zip","observables","resultSelector","length","pop","undefined","lift","ZipOperator","constructor","call","subscriber","source","subscribe","ZipSubscriber","destination","values","Object","create","iterators","active","_next","value","push","StaticArrayIterator","StaticIterator","ZipBufferIterator","_complete","len","unsubscribe","complete","i","stillUnsubscribed","add","notifyInactive","checkIterators","hasValue","shouldComplete","args","result","next","hasCompleted","done","_tryresultSelector","apply","err","error","nextResult","Boolean","array","index","parent","observable","buffer","isComplete","shift","notifyComplete","notifyNext","innerValue"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\observable\\zip.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { fromArray } from './fromArray';\nimport { isArray } from '../util/isArray';\nimport { Operator } from '../Operator';\nimport { ObservableInput, PartialObserver, ObservedValueOf } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { iterator as Symbol_iterator } from '../../internal/symbol/iterator';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, R>(v1: O1, resultSelector: (v1: ObservedValueOf<O1>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, R>(v1: O1, v2: O2, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>, v6: ObservedValueOf<O6>) => R): Observable<R>;\n\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(v1: O1, v2: O2): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>]>;\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>]>;\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>]>;\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>]>;\nexport function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>, ObservedValueOf<O6>]>;\n\nexport function zip<O extends ObservableInput<any>>(array: O[]): Observable<ObservedValueOf<O>[]>;\nexport function zip<R>(array: ObservableInput<any>[]): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<O extends ObservableInput<any>, R>(array: O[], resultSelector: (...values: ObservedValueOf<O>[]) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<R>(array: ObservableInput<any>[], resultSelector: (...values: any[]) => R): Observable<R>;\n\nexport function zip<O extends ObservableInput<any>>(...observables: O[]): Observable<ObservedValueOf<O>[]>;\nexport function zip<O extends ObservableInput<any>, R>(...observables: Array<O | ((...values: ObservedValueOf<O>[]) => R)>): Observable<R>;\nexport function zip<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the last parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * ## Example\n * Combine age and name from different sources\n * ```ts\n * import { zip, of } from 'rxjs';\n * import { map } from 'rxjs/operators';\n *\n * let age$ = of<number>(27, 25, 29);\n * let name$ = of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = of<boolean>(true, true, false);\n *\n * zip(age$, name$, isDev$).pipe(\n *   map(([age, name, isDev]) => ({ age, name, isDev })),\n * )\n * .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n * ```\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nexport function zip<O extends ObservableInput<any>, R>(\n  ...observables: Array<O | ((...values: ObservedValueOf<O>[]) => R)>\n): Observable<ObservedValueOf<O>[]|R> {\n  const resultSelector = <((...ys: Array<any>) => R)> observables[observables.length - 1];\n  if (typeof resultSelector === 'function') {\n    observables.pop();\n  }\n  return fromArray(observables, undefined).lift(new ZipOperator(resultSelector));\n}\n\nexport class ZipOperator<T, R> implements Operator<T, R> {\n\n  resultSelector?: (...values: Array<any>) => R;\n\n  constructor(resultSelector?: (...values: Array<any>) => R) {\n    this.resultSelector = resultSelector;\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ZipSubscriber<T, R> extends Subscriber<T> {\n  private iterators: LookAheadIterator<any>[] = [];\n  private active = 0;\n\n  constructor(destination: Subscriber<R>,\n              private resultSelector?: (...values: Array<any>) => R,\n              values: any = Object.create(null)) {\n    super(destination);\n    this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : undefined;\n  }\n\n  protected _next(value: any) {\n    const iterators = this.iterators;\n    if (isArray(value)) {\n      iterators.push(new StaticArrayIterator(value));\n    } else if (typeof value[Symbol_iterator] === 'function') {\n      iterators.push(new StaticIterator(value[Symbol_iterator]()));\n    } else {\n      iterators.push(new ZipBufferIterator(this.destination, this, value));\n    }\n  }\n\n  protected _complete() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n\n    this.unsubscribe();\n\n    if (len === 0) {\n      this.destination.complete!();\n      return;\n    }\n\n    this.active = len;\n    for (let i = 0; i < len; i++) {\n      let iterator: ZipBufferIterator<any, any> = <any>iterators[i];\n      if (iterator.stillUnsubscribed) {\n        const destination = this.destination as Subscription;\n        destination.add(iterator.subscribe());\n      } else {\n        this.active--; // not an observable\n      }\n    }\n  }\n\n  notifyInactive() {\n    this.active--;\n    if (this.active === 0) {\n      this.destination.complete!();\n    }\n  }\n\n  checkIterators() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n    const destination = this.destination;\n\n    // abort if not all of them have values\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n        return;\n      }\n    }\n\n    let shouldComplete = false;\n    const args: any[] = [];\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      let result = iterator.next();\n\n      // check to see if it's completed now that you've gotten\n      // the next value.\n      if (iterator.hasCompleted()) {\n        shouldComplete = true;\n      }\n\n      if (result.done) {\n        destination.complete!();\n        return;\n      }\n\n      args.push(result.value);\n    }\n\n    if (this.resultSelector) {\n      this._tryresultSelector(args);\n    } else {\n      destination.next!(args);\n    }\n\n    if (shouldComplete) {\n      destination.complete!();\n    }\n  }\n\n  protected _tryresultSelector(args: any[]) {\n    let result: any;\n    try {\n      result = this.resultSelector!.apply(this, args);\n    } catch (err) {\n      this.destination.error!(err);\n      return;\n    }\n    this.destination.next!(result);\n  }\n}\n\ninterface LookAheadIterator<T> extends Iterator<T> {\n  hasValue(): boolean;\n  hasCompleted(): boolean;\n}\n\nclass StaticIterator<T> implements LookAheadIterator<T> {\n  private nextResult: IteratorResult<T>;\n\n  constructor(private iterator: Iterator<T>) {\n    this.nextResult = iterator.next();\n  }\n\n  hasValue() {\n    return true;\n  }\n\n  next(): IteratorResult<T> {\n    const result = this.nextResult;\n    this.nextResult = this.iterator.next();\n    return result;\n  }\n\n  hasCompleted(): boolean {\n    const nextResult = this.nextResult;\n    return Boolean(nextResult && nextResult.done);\n  }\n}\n\nclass StaticArrayIterator<T> implements LookAheadIterator<T> {\n  private index = 0;\n  private length = 0;\n\n  constructor(private array: T[]) {\n    this.length = array.length;\n  }\n\n  [Symbol_iterator]() {\n    return this;\n  }\n\n  next(value?: any): IteratorResult<T> {\n    const i = this.index++;\n    const array = this.array;\n    return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n  }\n\n  hasValue() {\n    return this.array.length > this.index;\n  }\n\n  hasCompleted() {\n    return this.array.length === this.index;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ZipBufferIterator<T, R> extends SimpleOuterSubscriber<T, R> implements LookAheadIterator<T> {\n  stillUnsubscribed = true;\n  buffer: T[] = [];\n  isComplete = false;\n\n  constructor(destination: PartialObserver<T>,\n              private parent: ZipSubscriber<T, R>,\n              private observable: Observable<T>) {\n    super(destination);\n  }\n\n  [Symbol_iterator]() {\n    return this;\n  }\n\n  // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n  //    this is legit because `next()` will never be called by a subscription in this case.\n  next(): IteratorResult<T> {\n    const buffer = this.buffer;\n    if (buffer.length === 0 && this.isComplete) {\n      return { value: null, done: true };\n    } else {\n      return { value: buffer.shift()!, done: false };\n    }\n  }\n\n  hasValue() {\n    return this.buffer.length > 0;\n  }\n\n  hasCompleted() {\n    return this.buffer.length === 0 && this.isComplete;\n  }\n\n  notifyComplete() {\n    if (this.buffer.length > 0) {\n      this.isComplete = true;\n      this.parent.notifyInactive();\n    } else {\n      this.destination.complete!();\n    }\n  }\n\n  notifyNext(innerValue: any): void {\n    this.buffer.push(innerValue);\n    this.parent.checkIterators();\n  }\n\n  subscribe() {\n    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}