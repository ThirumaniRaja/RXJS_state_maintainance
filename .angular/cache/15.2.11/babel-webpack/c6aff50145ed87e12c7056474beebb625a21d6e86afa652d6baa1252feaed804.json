{"ast":null,"code":"import { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n  let length = arguments.length;\n  let scheduler = async;\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n  let bufferCreationInterval = null;\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n  let maxBufferSize = Number.POSITIVE_INFINITY;\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n  return function bufferTimeOperatorFunction(source) {\n    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\nclass BufferTimeOperator {\n  constructor(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n  }\n}\nclass Context {\n  constructor() {\n    this.buffer = [];\n  }\n}\nclass BufferTimeSubscriber extends Subscriber {\n  constructor(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    super(destination);\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n    this.contexts = [];\n    const context = this.openContext();\n    this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n    if (this.timespanOnly) {\n      const timeSpanOnlyState = {\n        subscriber: this,\n        context,\n        bufferTimeSpan\n      };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      const closeState = {\n        subscriber: this,\n        context\n      };\n      const creationState = {\n        bufferTimeSpan,\n        bufferCreationInterval,\n        subscriber: this,\n        scheduler\n      };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n  }\n  _next(value) {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    let filledBufferContext;\n    for (let i = 0; i < len; i++) {\n      const context = contexts[i];\n      const buffer = context.buffer;\n      buffer.push(value);\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context;\n      }\n    }\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  }\n  _error(err) {\n    this.contexts.length = 0;\n    super._error(err);\n  }\n  _complete() {\n    const {\n      contexts,\n      destination\n    } = this;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      destination.next(context.buffer);\n    }\n    super._complete();\n  }\n  _unsubscribe() {\n    this.contexts = null;\n  }\n  onBufferFull(context) {\n    this.closeContext(context);\n    const closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      const bufferTimeSpan = this.bufferTimeSpan;\n      const timeSpanOnlyState = {\n        subscriber: this,\n        context,\n        bufferTimeSpan\n      };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  }\n  openContext() {\n    const context = new Context();\n    this.contexts.push(context);\n    return context;\n  }\n  closeContext(context) {\n    this.destination.next(context.buffer);\n    const contexts = this.contexts;\n    const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  }\n}\nfunction dispatchBufferTimeSpanOnly(state) {\n  const subscriber = state.subscriber;\n  const prevContext = state.context;\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\nfunction dispatchBufferCreation(state) {\n  const {\n    bufferCreationInterval,\n    bufferTimeSpan,\n    subscriber,\n    scheduler\n  } = state;\n  const context = subscriber.openContext();\n  const action = this;\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber,\n      context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\nfunction dispatchBufferClose(arg) {\n  const {\n    subscriber,\n    context\n  } = arg;\n  subscriber.closeContext(context);\n}","map":{"version":3,"names":["async","Subscriber","isScheduler","bufferTime","bufferTimeSpan","length","arguments","scheduler","bufferCreationInterval","maxBufferSize","Number","POSITIVE_INFINITY","bufferTimeOperatorFunction","source","lift","BufferTimeOperator","constructor","call","subscriber","subscribe","BufferTimeSubscriber","Context","buffer","destination","contexts","context","openContext","timespanOnly","timeSpanOnlyState","add","closeAction","schedule","dispatchBufferTimeSpanOnly","closeState","creationState","dispatchBufferClose","dispatchBufferCreation","_next","value","len","filledBufferContext","i","push","onBufferFull","_error","err","_complete","shift","next","_unsubscribe","closeContext","unsubscribe","remove","closed","spliceIndex","indexOf","splice","state","prevContext","action","arg"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\bufferTime.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { isScheduler } from '../util/isScheduler';\nimport { OperatorFunction, SchedulerAction, SchedulerLike } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number | null | undefined, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number | null | undefined, maxBufferSize: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * ![](bufferTime.png)\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * ## Examples\n *\n * Every second, emit an array of the recent click events\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { bufferTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(1000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds, emit the click events from the next 2 seconds\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { bufferTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(2000, 5000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nexport function bufferTime<T>(bufferTimeSpan: number): OperatorFunction<T, T[]> {\n  let length: number = arguments.length;\n\n  let scheduler: SchedulerLike = async;\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  let bufferCreationInterval: number = null;\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  let maxBufferSize: number = Number.POSITIVE_INFINITY;\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferTimeOperator<T>(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nclass BufferTimeOperator<T> implements Operator<T, T[]> {\n  constructor(private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferTimeSubscriber(\n      subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler\n    ));\n  }\n}\n\nclass Context<T> {\n  buffer: T[] = [];\n  closeAction: Subscription;\n}\n\ninterface DispatchCreateArg<T> {\n  bufferTimeSpan: number;\n  bufferCreationInterval: number;\n  subscriber: BufferTimeSubscriber<T>;\n  scheduler: SchedulerLike;\n}\n\ninterface DispatchCloseArg<T> {\n  subscriber: BufferTimeSubscriber<T>;\n  context: Context<T>;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferTimeSubscriber<T> extends Subscriber<T> {\n  private contexts: Array<Context<T>> = [];\n  private timespanOnly: boolean;\n\n  constructor(destination: Subscriber<T[]>,\n              private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n    const context = this.openContext();\n    this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n    if (this.timespanOnly) {\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      const closeState = { subscriber: this, context };\n      const creationState: DispatchCreateArg<T> = { bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler };\n      this.add(context.closeAction = scheduler.schedule<DispatchCloseArg<T>>(dispatchBufferClose, bufferTimeSpan, closeState));\n      this.add(scheduler.schedule<DispatchCreateArg<T>>(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n  }\n\n  protected _next(value: T) {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    let filledBufferContext: Context<T>;\n    for (let i = 0; i < len; i++) {\n      const context = contexts[i];\n      const buffer = context.buffer;\n      buffer.push(value);\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  }\n\n  protected _error(err: any) {\n    this.contexts.length = 0;\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts, destination } = this;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      destination.next(context.buffer);\n    }\n    super._complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.contexts = null;\n  }\n\n  protected onBufferFull(context: Context<T>) {\n    this.closeContext(context);\n    const closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      const bufferTimeSpan = this.bufferTimeSpan;\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  openContext(): Context<T> {\n    const context: Context<T> = new Context<T>();\n    this.contexts.push(context);\n    return context;\n  }\n\n  closeContext(context: Context<T>) {\n    this.destination.next(context.buffer);\n    const contexts = this.contexts;\n\n    const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  }\n}\n\nfunction dispatchBufferTimeSpanOnly(this: SchedulerAction<any>, state: any) {\n  const subscriber: BufferTimeSubscriber<any> = state.subscriber;\n\n  const prevContext = state.context;\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation<T>(this: SchedulerAction<DispatchCreateArg<T>>, state: DispatchCreateArg<T>) {\n  const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;\n  const context = subscriber.openContext();\n  const action = <SchedulerAction<DispatchCreateArg<T>>>this;\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule<DispatchCloseArg<T>>(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose<T>(arg: DispatchCloseArg<T>) {\n  const { subscriber, context } = arg;\n  subscriber.closeContext(context);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}