{"ast":null,"code":"import { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\nexport function mergeScan(accumulator, seed, concurrent = Number.POSITIVE_INFINITY) {\n  return source => source.lift(new MergeScanOperator(accumulator, seed, concurrent));\n}\nexport class MergeScanOperator {\n  constructor(accumulator, seed, concurrent) {\n    this.accumulator = accumulator;\n    this.seed = seed;\n    this.concurrent = concurrent;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));\n  }\n}\nexport class MergeScanSubscriber extends SimpleOuterSubscriber {\n  constructor(destination, accumulator, acc, concurrent) {\n    super(destination);\n    this.accumulator = accumulator;\n    this.acc = acc;\n    this.concurrent = concurrent;\n    this.hasValue = false;\n    this.hasCompleted = false;\n    this.buffer = [];\n    this.active = 0;\n    this.index = 0;\n  }\n  _next(value) {\n    if (this.active < this.concurrent) {\n      const index = this.index++;\n      const destination = this.destination;\n      let ish;\n      try {\n        const {\n          accumulator\n        } = this;\n        ish = accumulator(this.acc, value, index);\n      } catch (e) {\n        return destination.error(e);\n      }\n      this.active++;\n      this._innerSub(ish);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n  _innerSub(ish) {\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    const destination = this.destination;\n    destination.add(innerSubscriber);\n    const innerSubscription = innerSubscribe(ish, innerSubscriber);\n    if (innerSubscription !== innerSubscriber) {\n      destination.add(innerSubscription);\n    }\n  }\n  _complete() {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n      this.destination.complete();\n    }\n    this.unsubscribe();\n  }\n  notifyNext(innerValue) {\n    const {\n      destination\n    } = this;\n    this.acc = innerValue;\n    this.hasValue = true;\n    destination.next(innerValue);\n  }\n  notifyComplete() {\n    const buffer = this.buffer;\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n      this.destination.complete();\n    }\n  }\n}","map":{"version":3,"names":["SimpleOuterSubscriber","SimpleInnerSubscriber","innerSubscribe","mergeScan","accumulator","seed","concurrent","Number","POSITIVE_INFINITY","source","lift","MergeScanOperator","constructor","call","subscriber","subscribe","MergeScanSubscriber","destination","acc","hasValue","hasCompleted","buffer","active","index","_next","value","ish","e","error","_innerSub","push","innerSubscriber","add","innerSubscription","_complete","length","next","complete","unsubscribe","notifyNext","innerValue","notifyComplete","shift"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\mergeScan.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * ## Example\n * Count the number of click events\n * ```ts\n * import { fromEvent, of } from 'rxjs';\n * import { mapTo, mergeScan } from 'rxjs/operators';\n *\n * const click$ = fromEvent(document, 'click');\n * const one$ = click$.pipe(mapTo(1));\n * const seed = 0;\n * const count$ = one$.pipe(\n *   mergeScan((acc, one) => of(acc + one), seed),\n * );\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * // 1\n * // 2\n * // 3\n * // 4\n * // ...and so on for each click\n * ```\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nexport function mergeScan<T, R>(accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\n                                seed: R,\n                                concurrent: number = Number.POSITIVE_INFINITY): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new MergeScanOperator(accumulator, seed, concurrent));\n}\n\nexport class MergeScanOperator<T, R> implements Operator<T, R> {\n  constructor(private accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\n              private seed: R,\n              private concurrent: number) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MergeScanSubscriber(\n      subscriber, this.accumulator, this.seed, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeScanSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private hasValue: boolean = false;\n  private hasCompleted: boolean = false;\n  private buffer: Observable<any>[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\n              private acc: R,\n              private concurrent: number) {\n    super(destination);\n  }\n\n  protected _next(value: any): void {\n    if (this.active < this.concurrent) {\n      const index = this.index++;\n      const destination = this.destination;\n      let ish;\n      try {\n        const { accumulator } = this;\n        ish = accumulator(this.acc, value, index);\n      } catch (e) {\n        return destination.error!(e);\n      }\n      this.active++;\n      this._innerSub(ish);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  private _innerSub(ish: any): void {\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscriber);\n    const innerSubscription = innerSubscribe(ish, innerSubscriber);\n    // The returned subscription will usually be the subscriber that was\n    // passed. However, interop subscribers will be wrapped and for\n    // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n    if (innerSubscription !== innerSubscriber) {\n      destination.add(innerSubscription);\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      if (this.hasValue === false) {\n        this.destination.next!(this.acc);\n      }\n      this.destination.complete!();\n    }\n    this.unsubscribe();\n  }\n\n  notifyNext(innerValue: R): void {\n    const { destination } = this;\n    this.acc = innerValue;\n    this.hasValue = true;\n    destination.next!(innerValue);\n  }\n\n  notifyComplete(): void {\n    const buffer = this.buffer;\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      if (this.hasValue === false) {\n        this.destination.next!(this.acc);\n      }\n      this.destination.complete!();\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}