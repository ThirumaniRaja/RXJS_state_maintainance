{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nimport { noop } from '../util/noop';\nimport { isFunction } from '../util/isFunction';\nexport function tap(nextOrObserver, error, complete) {\n  return function tapOperatorFunction(source) {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\nclass DoOperator {\n  constructor(nextOrObserver, error, complete) {\n    this.nextOrObserver = nextOrObserver;\n    this.error = error;\n    this.complete = complete;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  }\n}\nclass TapSubscriber extends Subscriber {\n  constructor(destination, observerOrNext, error, complete) {\n    super(destination);\n    this._tapNext = noop;\n    this._tapError = noop;\n    this._tapComplete = noop;\n    this._tapError = error || noop;\n    this._tapComplete = complete || noop;\n    if (isFunction(observerOrNext)) {\n      this._context = this;\n      this._tapNext = observerOrNext;\n    } else if (observerOrNext) {\n      this._context = observerOrNext;\n      this._tapNext = observerOrNext.next || noop;\n      this._tapError = observerOrNext.error || noop;\n      this._tapComplete = observerOrNext.complete || noop;\n    }\n  }\n  _next(value) {\n    try {\n      this._tapNext.call(this._context, value);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(value);\n  }\n  _error(err) {\n    try {\n      this._tapError.call(this._context, err);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.error(err);\n  }\n  _complete() {\n    try {\n      this._tapComplete.call(this._context);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    return this.destination.complete();\n  }\n}","map":{"version":3,"names":["Subscriber","noop","isFunction","tap","nextOrObserver","error","complete","tapOperatorFunction","source","lift","DoOperator","constructor","call","subscriber","subscribe","TapSubscriber","destination","observerOrNext","_tapNext","_tapError","_tapComplete","_context","next","_next","value","err","_error","_complete"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\tap.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, PartialObserver, TeardownLogic } from '../types';\nimport { noop } from '../util/noop';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Use an observer instead of a complete callback */\nexport function tap<T>(next: null | undefined, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\n/** @deprecated Use an observer instead of an error callback */\nexport function tap<T>(next: null | undefined, error: (error: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\n/** @deprecated Use an observer instead of a complete callback */\nexport function tap<T>(next: (value: T) => void, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(next?: (x: T) => void, error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(observer: PartialObserver<T>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * ![](do.png)\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `tap` is not subscribed, the side effects specified by the\n * Observer will never happen. `tap` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * ## Example\n * Map every click to the clientX position of that click, while also logging the click event\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { tap, map } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(\n *   tap(ev => console.log(ev)),\n *   map(ev => ev.clientX),\n * );\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n * @see {@link Observable#subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nexport function tap<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n                       error?: (e: any) => void,\n                       complete?: () => void): MonoTypeOperatorFunction<T> {\n  return function tapOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\n\nclass DoOperator<T> implements Operator<T, T> {\n  constructor(private nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n              private error?: (e: any) => void,\n              private complete?: () => void) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nclass TapSubscriber<T> extends Subscriber<T> {\n  private _context: any;\n\n  private _tapNext: ((value: T) => void) = noop;\n\n  private _tapError: ((err: any) => void) = noop;\n\n  private _tapComplete: (() => void) = noop;\n\n  constructor(destination: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n      super(destination);\n      this._tapError = error || noop;\n      this._tapComplete = complete || noop;\n      if (isFunction(observerOrNext)) {\n        this._context = this;\n        this._tapNext = observerOrNext;\n      } else if (observerOrNext) {\n        this._context = observerOrNext;\n        this._tapNext = observerOrNext.next || noop;\n        this._tapError = observerOrNext.error || noop;\n        this._tapComplete = observerOrNext.complete || noop;\n      }\n    }\n\n  _next(value: T) {\n    try {\n      this._tapNext.call(this._context, value);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(value);\n  }\n\n  _error(err: any) {\n    try {\n      this._tapError.call(this._context, err);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.error(err);\n  }\n\n  _complete() {\n    try {\n      this._tapComplete.call(this._context, );\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    return this.destination.complete();\n  }\n}\n"],"mappings":"AACA,SAASA,UAAU,QAAQ,eAAe;AAG1C,SAASC,IAAI,QAAQ,cAAc;AACnC,SAASC,UAAU,QAAQ,oBAAoB;AA6D/C,OAAM,SAAUC,GAAGA,CAAIC,cAAsD,EACtDC,KAAwB,EACxBC,QAAqB;EAC1C,OAAO,SAASC,mBAAmBA,CAACC,MAAqB;IACvD,OAAOA,MAAM,CAACC,IAAI,CAAC,IAAIC,UAAU,CAACN,cAAc,EAAEC,KAAK,EAAEC,QAAQ,CAAC,CAAC;EACrE,CAAC;AACH;AAEA,MAAMI,UAAU;EACdC,YAAoBP,cAAsD,EACtDC,KAAwB,EACxBC,QAAqB;IAFrB,KAAAF,cAAc,GAAdA,cAAc;IACd,KAAAC,KAAK,GAALA,KAAK;IACL,KAAAC,QAAQ,GAARA,QAAQ;EAC5B;EACAM,IAAIA,CAACC,UAAyB,EAAEL,MAAW;IACzC,OAAOA,MAAM,CAACM,SAAS,CAAC,IAAIC,aAAa,CAACF,UAAU,EAAE,IAAI,CAACT,cAAc,EAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACC,QAAQ,CAAC,CAAC;EACxG;;AASF,MAAMS,aAAiB,SAAQf,UAAa;EAS1CW,YAAYK,WAA0B,EAC1BC,cAA0D,EAC1DZ,KAAyB,EACzBC,QAAqB;IAC7B,KAAK,CAACU,WAAW,CAAC;IAVd,KAAAE,QAAQ,GAAyBjB,IAAI;IAErC,KAAAkB,SAAS,GAAyBlB,IAAI;IAEtC,KAAAmB,YAAY,GAAiBnB,IAAI;IAOrC,IAAI,CAACkB,SAAS,GAAGd,KAAK,IAAIJ,IAAI;IAC9B,IAAI,CAACmB,YAAY,GAAGd,QAAQ,IAAIL,IAAI;IACpC,IAAIC,UAAU,CAACe,cAAc,CAAC,EAAE;MAC9B,IAAI,CAACI,QAAQ,GAAG,IAAI;MACpB,IAAI,CAACH,QAAQ,GAAGD,cAAc;KAC/B,MAAM,IAAIA,cAAc,EAAE;MACzB,IAAI,CAACI,QAAQ,GAAGJ,cAAc;MAC9B,IAAI,CAACC,QAAQ,GAAGD,cAAc,CAACK,IAAI,IAAIrB,IAAI;MAC3C,IAAI,CAACkB,SAAS,GAAGF,cAAc,CAACZ,KAAK,IAAIJ,IAAI;MAC7C,IAAI,CAACmB,YAAY,GAAGH,cAAc,CAACX,QAAQ,IAAIL,IAAI;;EAEvD;EAEFsB,KAAKA,CAACC,KAAQ;IACZ,IAAI;MACF,IAAI,CAACN,QAAQ,CAACN,IAAI,CAAC,IAAI,CAACS,QAAQ,EAAEG,KAAK,CAAC;KACzC,CAAC,OAAOC,GAAG,EAAE;MACZ,IAAI,CAACT,WAAW,CAACX,KAAK,CAACoB,GAAG,CAAC;MAC3B;;IAEF,IAAI,CAACT,WAAW,CAACM,IAAI,CAACE,KAAK,CAAC;EAC9B;EAEAE,MAAMA,CAACD,GAAQ;IACb,IAAI;MACF,IAAI,CAACN,SAAS,CAACP,IAAI,CAAC,IAAI,CAACS,QAAQ,EAAEI,GAAG,CAAC;KACxC,CAAC,OAAOA,GAAG,EAAE;MACZ,IAAI,CAACT,WAAW,CAACX,KAAK,CAACoB,GAAG,CAAC;MAC3B;;IAEF,IAAI,CAACT,WAAW,CAACX,KAAK,CAACoB,GAAG,CAAC;EAC7B;EAEAE,SAASA,CAAA;IACP,IAAI;MACF,IAAI,CAACP,YAAY,CAACR,IAAI,CAAC,IAAI,CAACS,QAAQ,CAAG;KACxC,CAAC,OAAOI,GAAG,EAAE;MACZ,IAAI,CAACT,WAAW,CAACX,KAAK,CAACoB,GAAG,CAAC;MAC3B;;IAEF,OAAO,IAAI,CAACT,WAAW,CAACV,QAAQ,EAAE;EACpC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}