{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nexport function retry(count = -1) {\n  return source => source.lift(new RetryOperator(count, source));\n}\nclass RetryOperator {\n  constructor(count, source) {\n    this.count = count;\n    this.source = source;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n  }\n}\nclass RetrySubscriber extends Subscriber {\n  constructor(destination, count, source) {\n    super(destination);\n    this.count = count;\n    this.source = source;\n  }\n  error(err) {\n    if (!this.isStopped) {\n      const {\n        source,\n        count\n      } = this;\n      if (count === 0) {\n        return super.error(err);\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  }\n}","map":{"version":3,"names":["Subscriber","retry","count","source","lift","RetryOperator","constructor","call","subscriber","subscribe","RetrySubscriber","destination","error","err","isStopped","_unsubscribeAndRecycle"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\retry.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * ![](retry.png)\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n *\n * ## Example\n * ```ts\n * import { interval, of, throwError } from 'rxjs';\n * import { mergeMap, retry } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const example = source.pipe(\n *   mergeMap(val => {\n *     if(val > 5){\n *       return throwError('Error!');\n *     }\n *     return of(val);\n *   }),\n *   //retry 2 times on error\n *   retry(2)\n * );\n *\n * const subscribe = example.subscribe({\n *   next: val => console.log(val),\n *   error: val => console.log(`${val}: Retried 2 times then quit!`)\n * });\n *\n * // Output:\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // \"Error!: Retried 2 times then quit!\"\n * ```\n *\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nexport function retry<T>(count: number = -1): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RetryOperator(count, source));\n}\n\nclass RetryOperator<T> implements Operator<T, T> {\n  constructor(private count: number,\n              private source: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RetrySubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>,\n              private count: number,\n              private source: Observable<T>) {\n    super(destination);\n  }\n  error(err: any) {\n    if (!this.isStopped) {\n      const { source, count } = this;\n      if (count === 0) {\n        return super.error(err);\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  }\n}\n"],"mappings":"AACA,SAASA,UAAU,QAAQ,eAAe;AAmD1C,OAAM,SAAUC,KAAKA,CAAIC,KAAA,GAAgB,CAAC,CAAC;EACzC,OAAQC,MAAqB,IAAKA,MAAM,CAACC,IAAI,CAAC,IAAIC,aAAa,CAACH,KAAK,EAAEC,MAAM,CAAC,CAAC;AACjF;AAEA,MAAME,aAAa;EACjBC,YAAoBJ,KAAa,EACbC,MAAqB;IADrB,KAAAD,KAAK,GAALA,KAAK;IACL,KAAAC,MAAM,GAANA,MAAM;EAC1B;EAEAI,IAAIA,CAACC,UAAyB,EAAEL,MAAW;IACzC,OAAOA,MAAM,CAACM,SAAS,CAAC,IAAIC,eAAe,CAACF,UAAU,EAAE,IAAI,CAACN,KAAK,EAAE,IAAI,CAACC,MAAM,CAAC,CAAC;EACnF;;AAQF,MAAMO,eAAmB,SAAQV,UAAa;EAC5CM,YAAYK,WAA4B,EACpBT,KAAa,EACbC,MAAqB;IACvC,KAAK,CAACQ,WAAW,CAAC;IAFA,KAAAT,KAAK,GAALA,KAAK;IACL,KAAAC,MAAM,GAANA,MAAM;EAE1B;EACAS,KAAKA,CAACC,GAAQ;IACZ,IAAI,CAAC,IAAI,CAACC,SAAS,EAAE;MACnB,MAAM;QAAEX,MAAM;QAAED;MAAK,CAAE,GAAG,IAAI;MAC9B,IAAIA,KAAK,KAAK,CAAC,EAAE;QACf,OAAO,KAAK,CAACU,KAAK,CAACC,GAAG,CAAC;OACxB,MAAM,IAAIX,KAAK,GAAG,CAAC,CAAC,EAAE;QACrB,IAAI,CAACA,KAAK,GAAGA,KAAK,GAAG,CAAC;;MAExBC,MAAM,CAACM,SAAS,CAAC,IAAI,CAACM,sBAAsB,EAAE,CAAC;;EAEnD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}