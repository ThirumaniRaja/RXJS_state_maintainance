{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nexport function find(predicate, thisArg) {\n  if (typeof predicate !== 'function') {\n    throw new TypeError('predicate is not a function');\n  }\n  return source => source.lift(new FindValueOperator(predicate, source, false, thisArg));\n}\nexport class FindValueOperator {\n  constructor(predicate, source, yieldIndex, thisArg) {\n    this.predicate = predicate;\n    this.source = source;\n    this.yieldIndex = yieldIndex;\n    this.thisArg = thisArg;\n  }\n  call(observer, source) {\n    return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n  }\n}\nexport class FindValueSubscriber extends Subscriber {\n  constructor(destination, predicate, source, yieldIndex, thisArg) {\n    super(destination);\n    this.predicate = predicate;\n    this.source = source;\n    this.yieldIndex = yieldIndex;\n    this.thisArg = thisArg;\n    this.index = 0;\n  }\n  notifyComplete(value) {\n    const destination = this.destination;\n    destination.next(value);\n    destination.complete();\n    this.unsubscribe();\n  }\n  _next(value) {\n    const {\n      predicate,\n      thisArg\n    } = this;\n    const index = this.index++;\n    try {\n      const result = predicate.call(thisArg || this, value, index, this.source);\n      if (result) {\n        this.notifyComplete(this.yieldIndex ? index : value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n  _complete() {\n    this.notifyComplete(this.yieldIndex ? -1 : undefined);\n  }\n}","map":{"version":3,"names":["Subscriber","find","predicate","thisArg","TypeError","source","lift","FindValueOperator","constructor","yieldIndex","call","observer","subscribe","FindValueSubscriber","destination","index","notifyComplete","value","next","complete","unsubscribe","_next","result","err","error","_complete","undefined"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\find.ts"],"sourcesContent":["import {Observable} from '../Observable';\nimport {Operator} from '../Operator';\nimport {Subscriber} from '../Subscriber';\nimport {OperatorFunction} from '../types';\n\nexport function find<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S,\n                                     thisArg?: any): OperatorFunction<T, S | undefined>;\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                        thisArg?: any): OperatorFunction<T, T | undefined>;\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * ![](find.png)\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * ## Example\n * Find and emit the first click that happens on a DIV element\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { find } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(find(ev => ev.target.tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                        thisArg?: any): OperatorFunction<T, T | undefined> {\n  if (typeof predicate !== 'function') {\n    throw new TypeError('predicate is not a function');\n  }\n  return (source: Observable<T>) => source.lift(new FindValueOperator(predicate, source, false, thisArg)) as Observable<T | undefined>;\n}\n\nexport class FindValueOperator<T> implements Operator<T, T | number | undefined> {\n  constructor(private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private source: Observable<T>,\n              private yieldIndex: boolean,\n              private thisArg?: any) {\n  }\n\n  call(observer: Subscriber<T>, source: any): any {\n    return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class FindValueSubscriber<T> extends Subscriber<T> {\n  private index: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private source: Observable<T>,\n              private yieldIndex: boolean,\n              private thisArg?: any) {\n    super(destination);\n  }\n\n  private notifyComplete(value: any): void {\n    const destination = this.destination;\n\n    destination.next(value);\n    destination.complete();\n    this.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    const {predicate, thisArg} = this;\n    const index = this.index++;\n    try {\n      const result = predicate.call(thisArg || this, value, index, this.source);\n      if (result) {\n        this.notifyComplete(this.yieldIndex ? index : value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.notifyComplete(this.yieldIndex ? -1 : undefined);\n  }\n}\n"],"mappings":"AAEA,SAAQA,UAAU,QAAO,eAAe;AA8CxC,OAAM,SAAUC,IAAIA,CAAIC,SAAsE,EACtEC,OAAa;EACnC,IAAI,OAAOD,SAAS,KAAK,UAAU,EAAE;IACnC,MAAM,IAAIE,SAAS,CAAC,6BAA6B,CAAC;;EAEpD,OAAQC,MAAqB,IAAKA,MAAM,CAACC,IAAI,CAAC,IAAIC,iBAAiB,CAACL,SAAS,EAAEG,MAAM,EAAE,KAAK,EAAEF,OAAO,CAAC,CAA8B;AACtI;AAEA,OAAM,MAAOI,iBAAiB;EAC5BC,YAAoBN,SAAsE,EACtEG,MAAqB,EACrBI,UAAmB,EACnBN,OAAa;IAHb,KAAAD,SAAS,GAATA,SAAS;IACT,KAAAG,MAAM,GAANA,MAAM;IACN,KAAAI,UAAU,GAAVA,UAAU;IACV,KAAAN,OAAO,GAAPA,OAAO;EAC3B;EAEAO,IAAIA,CAACC,QAAuB,EAAEN,MAAW;IACvC,OAAOA,MAAM,CAACO,SAAS,CAAC,IAAIC,mBAAmB,CAACF,QAAQ,EAAE,IAAI,CAACT,SAAS,EAAE,IAAI,CAACG,MAAM,EAAE,IAAI,CAACI,UAAU,EAAE,IAAI,CAACN,OAAO,CAAC,CAAC;EACxH;;AAQF,OAAM,MAAOU,mBAAuB,SAAQb,UAAa;EAGvDQ,YAAYM,WAA0B,EAClBZ,SAAsE,EACtEG,MAAqB,EACrBI,UAAmB,EACnBN,OAAa;IAC/B,KAAK,CAACW,WAAW,CAAC;IAJA,KAAAZ,SAAS,GAATA,SAAS;IACT,KAAAG,MAAM,GAANA,MAAM;IACN,KAAAI,UAAU,GAAVA,UAAU;IACV,KAAAN,OAAO,GAAPA,OAAO;IANnB,KAAAY,KAAK,GAAW,CAAC;EAQzB;EAEQC,cAAcA,CAACC,KAAU;IAC/B,MAAMH,WAAW,GAAG,IAAI,CAACA,WAAW;IAEpCA,WAAW,CAACI,IAAI,CAACD,KAAK,CAAC;IACvBH,WAAW,CAACK,QAAQ,EAAE;IACtB,IAAI,CAACC,WAAW,EAAE;EACpB;EAEUC,KAAKA,CAACJ,KAAQ;IACtB,MAAM;MAACf,SAAS;MAAEC;IAAO,CAAC,GAAG,IAAI;IACjC,MAAMY,KAAK,GAAG,IAAI,CAACA,KAAK,EAAE;IAC1B,IAAI;MACF,MAAMO,MAAM,GAAGpB,SAAS,CAACQ,IAAI,CAACP,OAAO,IAAI,IAAI,EAAEc,KAAK,EAAEF,KAAK,EAAE,IAAI,CAACV,MAAM,CAAC;MACzE,IAAIiB,MAAM,EAAE;QACV,IAAI,CAACN,cAAc,CAAC,IAAI,CAACP,UAAU,GAAGM,KAAK,GAAGE,KAAK,CAAC;;KAEvD,CAAC,OAAOM,GAAG,EAAE;MACZ,IAAI,CAACT,WAAW,CAACU,KAAK,CAACD,GAAG,CAAC;;EAE/B;EAEUE,SAASA,CAAA;IACjB,IAAI,CAACT,cAAc,CAAC,IAAI,CAACP,UAAU,GAAG,CAAC,CAAC,GAAGiB,SAAS,CAAC;EACvD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}