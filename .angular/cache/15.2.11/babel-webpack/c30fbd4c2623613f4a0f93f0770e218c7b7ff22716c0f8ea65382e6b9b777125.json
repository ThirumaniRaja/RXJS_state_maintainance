{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nimport { Subject } from '../Subject';\nexport function windowCount(windowSize, startWindowEvery = 0) {\n  return function windowCountOperatorFunction(source) {\n    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));\n  };\n}\nclass WindowCountOperator {\n  constructor(windowSize, startWindowEvery) {\n    this.windowSize = windowSize;\n    this.startWindowEvery = startWindowEvery;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n  }\n}\nclass WindowCountSubscriber extends Subscriber {\n  constructor(destination, windowSize, startWindowEvery) {\n    super(destination);\n    this.destination = destination;\n    this.windowSize = windowSize;\n    this.startWindowEvery = startWindowEvery;\n    this.windows = [new Subject()];\n    this.count = 0;\n    destination.next(this.windows[0]);\n  }\n  _next(value) {\n    const startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;\n    const destination = this.destination;\n    const windowSize = this.windowSize;\n    const windows = this.windows;\n    const len = windows.length;\n    for (let i = 0; i < len && !this.closed; i++) {\n      windows[i].next(value);\n    }\n    const c = this.count - windowSize + 1;\n    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n      windows.shift().complete();\n    }\n    if (++this.count % startWindowEvery === 0 && !this.closed) {\n      const window = new Subject();\n      windows.push(window);\n      destination.next(window);\n    }\n  }\n  _error(err) {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().error(err);\n      }\n    }\n    this.destination.error(err);\n  }\n  _complete() {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().complete();\n      }\n    }\n    this.destination.complete();\n  }\n  _unsubscribe() {\n    this.count = 0;\n    this.windows = null;\n  }\n}","map":{"version":3,"names":["Subscriber","Subject","windowCount","windowSize","startWindowEvery","windowCountOperatorFunction","source","lift","WindowCountOperator","constructor","call","subscriber","subscribe","WindowCountSubscriber","destination","windows","count","next","_next","value","len","length","i","closed","c","shift","complete","window","push","_error","err","error","_complete","_unsubscribe"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\windowCount.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowCount.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * ## Examples\n * Ignore every 3rd click event, starting from the first one\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowCount, map, mergeAll, skip } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(3),\n *   map(win => win.pipe(skip(1))), // skip first of every 3 clicks\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Ignore every 3rd click event, starting from the third one\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowCount, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(2, 3),\n *   mergeAll(),              // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nexport function windowCount<T>(windowSize: number,\n                               startWindowEvery: number = 0): OperatorFunction<T, Observable<T>> {\n  return function windowCountOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowCountOperator<T>(windowSize, startWindowEvery));\n  };\n}\n\nclass WindowCountOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowSize: number,\n              private startWindowEvery: number) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowCountSubscriber<T> extends Subscriber<T> {\n  private windows: Subject<T>[] = [ new Subject<T>() ];\n  private count: number = 0;\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private windowSize: number,\n              private startWindowEvery: number) {\n    super(destination);\n    destination.next(this.windows[0]);\n  }\n\n  protected _next(value: T) {\n    const startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n    const destination = this.destination;\n    const windowSize = this.windowSize;\n    const windows = this.windows;\n    const len = windows.length;\n\n    for (let i = 0; i < len && !this.closed; i++) {\n      windows[i].next(value);\n    }\n    const c = this.count - windowSize + 1;\n    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n      windows.shift().complete();\n    }\n    if (++this.count % startWindowEvery === 0 && !this.closed) {\n      const window = new Subject<T>();\n      windows.push(window);\n      destination.next(window);\n    }\n  }\n\n  protected _error(err: any) {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().error(err);\n      }\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete() {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().complete();\n      }\n    }\n    this.destination.complete();\n  }\n\n  protected _unsubscribe() {\n    this.count = 0;\n    this.windows = null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}