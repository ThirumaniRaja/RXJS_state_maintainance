{"ast":null,"code":"import { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nexport function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n  if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n    scheduler = selectorOrScheduler;\n  }\n  const selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n  const subject = new ReplaySubject(bufferSize, windowTime, scheduler);\n  return source => multicast(() => subject, selector)(source);\n}","map":{"version":3,"names":["ReplaySubject","multicast","publishReplay","bufferSize","windowTime","selectorOrScheduler","scheduler","selector","undefined","subject","source"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\publishReplay.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction, MonoTypeOperatorFunction, OperatorFunction, SchedulerLike, ObservableInput, ObservedValueOf } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function publishReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport function publishReplay<T, O extends ObservableInput<any>>(bufferSize?: number, windowTime?: number, selector?: (shared: Observable<T>) => O, scheduler?: SchedulerLike): OperatorFunction<T, ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\nexport function publishReplay<T, R>(bufferSize?: number,\n                                    windowTime?: number,\n                                    selectorOrScheduler?: SchedulerLike | OperatorFunction<T, R>,\n                                    scheduler?: SchedulerLike): UnaryFunction<Observable<T>, ConnectableObservable<R>> {\n\n  if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n    scheduler = selectorOrScheduler;\n  }\n\n  const selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n  const subject = new ReplaySubject<T>(bufferSize, windowTime, scheduler);\n\n  return (source: Observable<T>) => multicast(() => subject, selector)(source) as ConnectableObservable<R>;\n}\n"],"mappings":"AACA,SAASA,aAAa,QAAQ,kBAAkB;AAChD,SAASC,SAAS,QAAQ,aAAa;AASvC,OAAM,SAAUC,aAAaA,CAAOC,UAAmB,EACnBC,UAAmB,EACnBC,mBAA4D,EAC5DC,SAAyB;EAE3D,IAAID,mBAAmB,IAAI,OAAOA,mBAAmB,KAAK,UAAU,EAAE;IACpEC,SAAS,GAAGD,mBAAmB;;EAGjC,MAAME,QAAQ,GAAG,OAAOF,mBAAmB,KAAK,UAAU,GAAGA,mBAAmB,GAAGG,SAAS;EAC5F,MAAMC,OAAO,GAAG,IAAIT,aAAa,CAAIG,UAAU,EAAEC,UAAU,EAAEE,SAAS,CAAC;EAEvE,OAAQI,MAAqB,IAAKT,SAAS,CAAC,MAAMQ,OAAO,EAAEF,QAAQ,CAAC,CAACG,MAAM,CAA6B;AAC1G","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}