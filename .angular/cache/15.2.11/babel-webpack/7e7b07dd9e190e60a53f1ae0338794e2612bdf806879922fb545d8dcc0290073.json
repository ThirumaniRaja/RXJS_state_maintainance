{"ast":null,"code":"import { from } from '../observable/from';\nimport { isArray } from '../util/isArray';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\nexport function onErrorResumeNext(...nextSources) {\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = nextSources[0];\n  }\n  return source => source.lift(new OnErrorResumeNextOperator(nextSources));\n}\nexport function onErrorResumeNextStatic(...nextSources) {\n  let source = undefined;\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = nextSources[0];\n  }\n  source = nextSources.shift();\n  return from(source).lift(new OnErrorResumeNextOperator(nextSources));\n}\nclass OnErrorResumeNextOperator {\n  constructor(nextSources) {\n    this.nextSources = nextSources;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n  }\n}\nclass OnErrorResumeNextSubscriber extends SimpleOuterSubscriber {\n  constructor(destination, nextSources) {\n    super(destination);\n    this.destination = destination;\n    this.nextSources = nextSources;\n  }\n  notifyError() {\n    this.subscribeToNextSource();\n  }\n  notifyComplete() {\n    this.subscribeToNextSource();\n  }\n  _error(err) {\n    this.subscribeToNextSource();\n    this.unsubscribe();\n  }\n  _complete() {\n    this.subscribeToNextSource();\n    this.unsubscribe();\n  }\n  subscribeToNextSource() {\n    const next = this.nextSources.shift();\n    if (!!next) {\n      const innerSubscriber = new SimpleInnerSubscriber(this);\n      const destination = this.destination;\n      destination.add(innerSubscriber);\n      const innerSubscription = innerSubscribe(next, innerSubscriber);\n      if (innerSubscription !== innerSubscriber) {\n        destination.add(innerSubscription);\n      }\n    } else {\n      this.destination.complete();\n    }\n  }\n}","map":{"version":3,"names":["from","isArray","SimpleOuterSubscriber","SimpleInnerSubscriber","innerSubscribe","onErrorResumeNext","nextSources","length","source","lift","OnErrorResumeNextOperator","onErrorResumeNextStatic","undefined","shift","constructor","call","subscriber","subscribe","OnErrorResumeNextSubscriber","destination","notifyError","subscribeToNextSource","notifyComplete","_error","err","unsubscribe","_complete","next","innerSubscriber","add","innerSubscription","complete"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\onErrorResumeNext.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { from } from '../observable/from';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { isArray } from '../util/isArray';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNext<T>(): OperatorFunction<T, T>;\nexport function onErrorResumeNext<T, T2>(v: ObservableInput<T2>): OperatorFunction<T, T | T2>;\nexport function onErrorResumeNext<T, T2, T3>(v: ObservableInput<T2>, v2: ObservableInput<T3>): OperatorFunction<T, T | T2 | T3>;\nexport function onErrorResumeNext<T, T2, T3, T4>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>): OperatorFunction<T, T | T2 | T3 | T4>;\nexport function onErrorResumeNext<T, T2, T3, T4, T5>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\nexport function onErrorResumeNext<T, T2, T3, T4, T5, T6>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>, v5: ObservableInput<T6>): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\nexport function onErrorResumeNext<T, T2, T3, T4, T5, T6, T7>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>, v5: ObservableInput<T6>, v6: ObservableInput<T7>): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6 | T7>;\nexport function onErrorResumeNext<T, R>(...observables: Array<ObservableInput<any>>): OperatorFunction<T, T | R>;\nexport function onErrorResumeNext<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, T | R>;\n/* tslint:enable:max-line-length */\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link Observable#subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catchError} instead.\n *\n *\n * ## Example\n * Subscribe to the next Observable after map fails\n * ```ts\n * import { of } from 'rxjs';\n * import { onErrorResumeNext, map } from 'rxjs/operators';\n *\n * of(1, 2, 3, 0).pipe(\n *   map(x => {\n *       if (x === 0) { throw Error(); }\n *        return 10 / x;\n *   }),\n *   onErrorResumeNext(of(1, 2, 3)),\n * )\n * .subscribe(\n *   val => console.log(val),\n *   err => console.log(err),          // Will never be called.\n *   () => console.log('that\\'s it!')\n * );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\n\nexport function onErrorResumeNext<T, R>(...nextSources: Array<ObservableInput<any> |\n                                                       Array<ObservableInput<any>>>): OperatorFunction<T, R> {\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = <Array<Observable<any>>>nextSources[0];\n  }\n\n  return (source: Observable<T>) => source.lift(new OnErrorResumeNextOperator<T, R>(nextSources));\n}\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNextStatic<R>(v: ObservableInput<R>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;\n\nexport function onErrorResumeNextStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\nexport function onErrorResumeNextStatic<R>(array: ObservableInput<any>[]): Observable<R>;\n/* tslint:enable:max-line-length */\n\nexport function onErrorResumeNextStatic<T, R>(...nextSources: Array<ObservableInput<any> |\n  Array<ObservableInput<any>> |\n  ((...values: Array<any>) => R)>): Observable<R> {\n  let source: ObservableInput<any>|undefined = undefined;\n\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = nextSources[0] as ObservableInput<any>[];\n  }\n  // TODO: resolve issue with passing no arguments.\n  source = nextSources.shift()!;\n\n  return from(source).lift(new OnErrorResumeNextOperator<T, R>(nextSources));\n}\n\nclass OnErrorResumeNextOperator<T, R> implements Operator<T, R> {\n  constructor(private nextSources: Array<ObservableInput<any>>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n  }\n}\n\nclass OnErrorResumeNextSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  constructor(protected destination: Subscriber<T>,\n              private nextSources: Array<ObservableInput<any>>) {\n    super(destination);\n  }\n\n  notifyError(): void {\n    this.subscribeToNextSource();\n  }\n\n  notifyComplete(): void {\n    this.subscribeToNextSource();\n  }\n\n  protected _error(err: any): void {\n    this.subscribeToNextSource();\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.subscribeToNextSource();\n    this.unsubscribe();\n  }\n\n  private subscribeToNextSource(): void {\n    const next = this.nextSources.shift();\n    if (!!next) {\n      const innerSubscriber = new SimpleInnerSubscriber(this);\n      const destination = this.destination as Subscription;\n      destination.add(innerSubscriber);\n      const innerSubscription = innerSubscribe(next, innerSubscriber);\n      // The returned subscription will usually be the subscriber that was\n      // passed. However, interop subscribers will be wrapped and for\n      // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n      if (innerSubscription !== innerSubscriber) {\n        destination.add(innerSubscription);\n      }\n    } else {\n      this.destination.complete();\n    }\n  }\n}\n"],"mappings":"AACA,SAASA,IAAI,QAAQ,oBAAoB;AAIzC,SAASC,OAAO,QAAQ,iBAAiB;AAEzC,SAASC,qBAAqB,EAAEC,qBAAqB,EAAEC,cAAc,QAAQ,mBAAmB;AAmFhG,OAAM,SAAUC,iBAAiBA,CAAO,GAAGC,WACwC;EACjF,IAAIA,WAAW,CAACC,MAAM,KAAK,CAAC,IAAIN,OAAO,CAACK,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;IACvDA,WAAW,GAA2BA,WAAW,CAAC,CAAC,CAAC;;EAGtD,OAAQE,MAAqB,IAAKA,MAAM,CAACC,IAAI,CAAC,IAAIC,yBAAyB,CAAOJ,WAAW,CAAC,CAAC;AACjG;AAaA,OAAM,SAAUK,uBAAuBA,CAAO,GAAGL,WAEhB;EAC/B,IAAIE,MAAM,GAAmCI,SAAS;EAEtD,IAAIN,WAAW,CAACC,MAAM,KAAK,CAAC,IAAIN,OAAO,CAACK,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;IACvDA,WAAW,GAAGA,WAAW,CAAC,CAAC,CAA2B;;EAGxDE,MAAM,GAAGF,WAAW,CAACO,KAAK,EAAG;EAE7B,OAAOb,IAAI,CAACQ,MAAM,CAAC,CAACC,IAAI,CAAC,IAAIC,yBAAyB,CAAOJ,WAAW,CAAC,CAAC;AAC5E;AAEA,MAAMI,yBAAyB;EAC7BI,YAAoBR,WAAwC;IAAxC,KAAAA,WAAW,GAAXA,WAAW;EAC/B;EAEAS,IAAIA,CAACC,UAAyB,EAAER,MAAW;IACzC,OAAOA,MAAM,CAACS,SAAS,CAAC,IAAIC,2BAA2B,CAACF,UAAU,EAAE,IAAI,CAACV,WAAW,CAAC,CAAC;EACxF;;AAGF,MAAMY,2BAAkC,SAAQhB,qBAA2B;EACzEY,YAAsBK,WAA0B,EAC5Bb,WAAwC;IAC1D,KAAK,CAACa,WAAW,CAAC;IAFE,KAAAA,WAAW,GAAXA,WAAW;IACb,KAAAb,WAAW,GAAXA,WAAW;EAE/B;EAEAc,WAAWA,CAAA;IACT,IAAI,CAACC,qBAAqB,EAAE;EAC9B;EAEAC,cAAcA,CAAA;IACZ,IAAI,CAACD,qBAAqB,EAAE;EAC9B;EAEUE,MAAMA,CAACC,GAAQ;IACvB,IAAI,CAACH,qBAAqB,EAAE;IAC5B,IAAI,CAACI,WAAW,EAAE;EACpB;EAEUC,SAASA,CAAA;IACjB,IAAI,CAACL,qBAAqB,EAAE;IAC5B,IAAI,CAACI,WAAW,EAAE;EACpB;EAEQJ,qBAAqBA,CAAA;IAC3B,MAAMM,IAAI,GAAG,IAAI,CAACrB,WAAW,CAACO,KAAK,EAAE;IACrC,IAAI,CAAC,CAACc,IAAI,EAAE;MACV,MAAMC,eAAe,GAAG,IAAIzB,qBAAqB,CAAC,IAAI,CAAC;MACvD,MAAMgB,WAAW,GAAG,IAAI,CAACA,WAA2B;MACpDA,WAAW,CAACU,GAAG,CAACD,eAAe,CAAC;MAChC,MAAME,iBAAiB,GAAG1B,cAAc,CAACuB,IAAI,EAAEC,eAAe,CAAC;MAI/D,IAAIE,iBAAiB,KAAKF,eAAe,EAAE;QACzCT,WAAW,CAACU,GAAG,CAACC,iBAAiB,CAAC;;KAErC,MAAM;MACL,IAAI,CAACX,WAAW,CAACY,QAAQ,EAAE;;EAE/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}