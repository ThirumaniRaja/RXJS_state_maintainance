{"ast":null,"code":"import { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function exhaust() {\n  return source => source.lift(new SwitchFirstOperator());\n}\nclass SwitchFirstOperator {\n  call(subscriber, source) {\n    return source.subscribe(new SwitchFirstSubscriber(subscriber));\n  }\n}\nclass SwitchFirstSubscriber extends SimpleOuterSubscriber {\n  constructor(destination) {\n    super(destination);\n    this.hasCompleted = false;\n    this.hasSubscription = false;\n  }\n  _next(value) {\n    if (!this.hasSubscription) {\n      this.hasSubscription = true;\n      this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));\n    }\n  }\n  _complete() {\n    this.hasCompleted = true;\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  }\n  notifyComplete() {\n    this.hasSubscription = false;\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}","map":{"version":3,"names":["SimpleOuterSubscriber","innerSubscribe","SimpleInnerSubscriber","exhaust","source","lift","SwitchFirstOperator","call","subscriber","subscribe","SwitchFirstSubscriber","constructor","destination","hasCompleted","hasSubscription","_next","value","add","_complete","complete","notifyComplete"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\exhaust.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\nexport function exhaust<T>(): OperatorFunction<ObservableInput<T>, T>;\nexport function exhaust<R>(): OperatorFunction<any, R>;\n\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * ![](exhaust.png)\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * ## Example\n * Run a finite timer for each click, only if there is no currently active timer\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { exhaust, map, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map((ev) => interval(1000).pipe(take(5))),\n * );\n * const result = higherOrder.pipe(exhaust());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\nexport function exhaust<T>(): OperatorFunction<any, T> {\n  return (source: Observable<T>) => source.lift(new SwitchFirstOperator<T>());\n}\n\nclass SwitchFirstOperator<T> implements Operator<T, T> {\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SwitchFirstSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchFirstSubscriber<T> extends SimpleOuterSubscriber<T, T> {\n  private hasCompleted: boolean = false;\n  private hasSubscription: boolean = false;\n\n  constructor(destination: Subscriber<T>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSubscription) {\n      this.hasSubscription = true;\n      this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (!this.hasSubscription) {\n      this.destination.complete!();\n    }\n  }\n\n  notifyComplete(): void {\n    this.hasSubscription = false;\n    if (this.hasCompleted) {\n      this.destination.complete!();\n    }\n  }\n}\n"],"mappings":"AAIA,SAASA,qBAAqB,EAAEC,cAAc,EAAEC,qBAAqB,QAAQ,mBAAmB;AAiDhG,OAAM,SAAUC,OAAOA,CAAA;EACrB,OAAQC,MAAqB,IAAKA,MAAM,CAACC,IAAI,CAAC,IAAIC,mBAAmB,EAAK,CAAC;AAC7E;AAEA,MAAMA,mBAAmB;EACvBC,IAAIA,CAACC,UAAyB,EAAEJ,MAAW;IACzC,OAAOA,MAAM,CAACK,SAAS,CAAC,IAAIC,qBAAqB,CAACF,UAAU,CAAC,CAAC;EAChE;;AAQF,MAAME,qBAAyB,SAAQV,qBAA2B;EAIhEW,YAAYC,WAA0B;IACpC,KAAK,CAACA,WAAW,CAAC;IAJZ,KAAAC,YAAY,GAAY,KAAK;IAC7B,KAAAC,eAAe,GAAY,KAAK;EAIxC;EAEUC,KAAKA,CAACC,KAAQ;IACtB,IAAI,CAAC,IAAI,CAACF,eAAe,EAAE;MACzB,IAAI,CAACA,eAAe,GAAG,IAAI;MAC3B,IAAI,CAACG,GAAG,CAAChB,cAAc,CAACe,KAAK,EAAE,IAAId,qBAAqB,CAAC,IAAI,CAAC,CAAC,CAAC;;EAEpE;EAEUgB,SAASA,CAAA;IACjB,IAAI,CAACL,YAAY,GAAG,IAAI;IACxB,IAAI,CAAC,IAAI,CAACC,eAAe,EAAE;MACzB,IAAI,CAACF,WAAW,CAACO,QAAS,EAAE;;EAEhC;EAEAC,cAAcA,CAAA;IACZ,IAAI,CAACN,eAAe,GAAG,KAAK;IAC5B,IAAI,IAAI,CAACD,YAAY,EAAE;MACrB,IAAI,CAACD,WAAW,CAACO,QAAS,EAAE;;EAEhC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}