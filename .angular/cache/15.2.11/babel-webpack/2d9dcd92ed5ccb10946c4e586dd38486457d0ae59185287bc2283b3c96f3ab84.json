{"ast":null,"code":"import { SubjectSubscriber } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nexport class ConnectableObservable extends Observable {\n  constructor(source, subjectFactory) {\n    super();\n    this.source = source;\n    this.subjectFactory = subjectFactory;\n    this._refCount = 0;\n    this._isComplete = false;\n  }\n  _subscribe(subscriber) {\n    return this.getSubject().subscribe(subscriber);\n  }\n  getSubject() {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n  connect() {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n  refCount() {\n    return higherOrderRefCount()(this);\n  }\n}\nexport const connectableObservableDescriptor = (() => {\n  const connectableProto = ConnectableObservable.prototype;\n  return {\n    operator: {\n      value: null\n    },\n    _refCount: {\n      value: 0,\n      writable: true\n    },\n    _subject: {\n      value: null,\n      writable: true\n    },\n    _connection: {\n      value: null,\n      writable: true\n    },\n    _subscribe: {\n      value: connectableProto._subscribe\n    },\n    _isComplete: {\n      value: connectableProto._isComplete,\n      writable: true\n    },\n    getSubject: {\n      value: connectableProto.getSubject\n    },\n    connect: {\n      value: connectableProto.connect\n    },\n    refCount: {\n      value: connectableProto.refCount\n    }\n  };\n})();\nclass ConnectableSubscriber extends SubjectSubscriber {\n  constructor(destination, connectable) {\n    super(destination);\n    this.connectable = connectable;\n  }\n  _error(err) {\n    this._unsubscribe();\n    super._error(err);\n  }\n  _complete() {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  _unsubscribe() {\n    const connectable = this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\nclass RefCountOperator {\n  constructor(connectable) {\n    this.connectable = connectable;\n  }\n  call(subscriber, source) {\n    const {\n      connectable\n    } = this;\n    connectable._refCount++;\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n    if (!refCounter.closed) {\n      refCounter.connection = connectable.connect();\n    }\n    return subscription;\n  }\n}\nclass RefCountSubscriber extends Subscriber {\n  constructor(destination, connectable) {\n    super(destination);\n    this.connectable = connectable;\n  }\n  _unsubscribe() {\n    const {\n      connectable\n    } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n    this.connectable = null;\n    const refCount = connectable._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n    connectable._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n    const {\n      connection\n    } = this;\n    const sharedConnection = connectable._connection;\n    this.connection = null;\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}","map":{"version":3,"names":["SubjectSubscriber","Observable","Subscriber","Subscription","refCount","higherOrderRefCount","ConnectableObservable","constructor","source","subjectFactory","_refCount","_isComplete","_subscribe","subscriber","getSubject","subscribe","subject","_subject","isStopped","connect","connection","_connection","add","ConnectableSubscriber","closed","EMPTY","connectableObservableDescriptor","connectableProto","prototype","operator","value","writable","destination","connectable","_error","err","_unsubscribe","_complete","unsubscribe","RefCountOperator","call","refCounter","RefCountSubscriber","subscription","sharedConnection"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\observable\\ConnectableObservable.ts"],"sourcesContent":["import { Subject, SubjectSubscriber } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { TeardownLogic } from '../types';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n\n  protected _subject: Subject<T>;\n  protected _refCount: number = 0;\n  protected _connection: Subscription;\n  /** @internal */\n  _isComplete = false;\n\n  constructor(public source: Observable<T>,\n              protected subjectFactory: () => Subject<T>) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n\nexport const connectableObservableDescriptor: PropertyDescriptorMap = (() => {\n  const connectableProto = <any>ConnectableObservable.prototype;\n  return {\n    operator: { value: null as null },\n    _refCount: { value: 0, writable: true },\n    _subject: { value: null as null, writable: true },\n    _connection: { value: null as null, writable: true },\n    _subscribe: { value: connectableProto._subscribe },\n    _isComplete: { value: connectableProto._isComplete, writable: true },\n    getSubject: { value: connectableProto.getSubject },\n    connect: { value: connectableProto.connect },\n    refCount: { value: connectableProto.refCount }\n  };\n})();\n\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\n  constructor(destination: Subject<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n  protected _error(err: any): void {\n    this._unsubscribe();\n    super._error(err);\n  }\n  protected _complete(): void {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  protected _unsubscribe() {\n    const connectable = <any>this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // ).subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}