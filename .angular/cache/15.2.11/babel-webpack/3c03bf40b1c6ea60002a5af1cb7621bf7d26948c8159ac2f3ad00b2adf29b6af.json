{"ast":null,"code":"import { Subject } from '../Subject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function windowWhen(closingSelector) {\n  return function windowWhenOperatorFunction(source) {\n    return source.lift(new WindowOperator(closingSelector));\n  };\n}\nclass WindowOperator {\n  constructor(closingSelector) {\n    this.closingSelector = closingSelector;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n  }\n}\nclass WindowSubscriber extends OuterSubscriber {\n  constructor(destination, closingSelector) {\n    super(destination);\n    this.destination = destination;\n    this.closingSelector = closingSelector;\n    this.openWindow();\n  }\n  notifyNext(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {\n    this.openWindow(innerSub);\n  }\n  notifyError(error) {\n    this._error(error);\n  }\n  notifyComplete(innerSub) {\n    this.openWindow(innerSub);\n  }\n  _next(value) {\n    this.window.next(value);\n  }\n  _error(err) {\n    this.window.error(err);\n    this.destination.error(err);\n    this.unsubscribeClosingNotification();\n  }\n  _complete() {\n    this.window.complete();\n    this.destination.complete();\n    this.unsubscribeClosingNotification();\n  }\n  unsubscribeClosingNotification() {\n    if (this.closingNotification) {\n      this.closingNotification.unsubscribe();\n    }\n  }\n  openWindow(innerSub = null) {\n    if (innerSub) {\n      this.remove(innerSub);\n      innerSub.unsubscribe();\n    }\n    const prevWindow = this.window;\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n    const window = this.window = new Subject();\n    this.destination.next(window);\n    let closingNotifier;\n    try {\n      const {\n        closingSelector\n      } = this;\n      closingNotifier = closingSelector();\n    } catch (e) {\n      this.destination.error(e);\n      this.window.error(e);\n      return;\n    }\n    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));\n  }\n}","map":{"version":3,"names":["Subject","OuterSubscriber","subscribeToResult","windowWhen","closingSelector","windowWhenOperatorFunction","source","lift","WindowOperator","constructor","call","subscriber","subscribe","WindowSubscriber","destination","openWindow","notifyNext","_outerValue","_innerValue","_outerIndex","_innerIndex","innerSub","notifyError","error","_error","notifyComplete","_next","value","window","next","err","unsubscribeClosingNotification","_complete","complete","closingNotification","unsubscribe","remove","prevWindow","closingNotifier","e","add"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\windowWhen.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowWhen.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * ## Example\n * Emit only the first two clicks events in every window of [1-5] random seconds\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { windowWhen, map, mergeAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowWhen(() => interval(1000 + Math.random() * 4000)),\n *   map(win => win.pipe(take(2))),     // each window has at most 2 emissions\n *   mergeAll()                         // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nexport function windowWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, Observable<T>> {\n  return function windowWhenOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowOperator<T>(closingSelector));\n  };\n}\n\nclass WindowOperator<T> implements Operator<T, Observable<T>> {\n  constructor(private closingSelector: () => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowSubscriber<T> extends OuterSubscriber<T, any> {\n  private window?: Subject<T>;\n  private closingNotification?: Subscription;\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private closingSelector: () => Observable<any>) {\n    super(destination);\n    this.openWindow();\n  }\n\n  notifyNext(_outerValue: T, _innerValue: any,\n             _outerIndex: number, _innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n    this.openWindow(innerSub);\n  }\n\n  notifyError(error: any): void {\n    this._error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, any>): void {\n    this.openWindow(innerSub);\n  }\n\n  protected _next(value: T): void {\n    this.window!.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.window!.error(err);\n    this.destination.error(err);\n    this.unsubscribeClosingNotification();\n  }\n\n  protected _complete(): void {\n    this.window!.complete();\n    this.destination.complete();\n    this.unsubscribeClosingNotification();\n  }\n\n  private unsubscribeClosingNotification(): void {\n    if (this.closingNotification) {\n      this.closingNotification.unsubscribe();\n    }\n  }\n\n  private openWindow(innerSub: InnerSubscriber<T, any> | null = null): void {\n    if (innerSub) {\n      this.remove(innerSub);\n      innerSub.unsubscribe();\n    }\n\n    const prevWindow = this.window;\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n\n    const window = this.window = new Subject<T>();\n    this.destination.next(window);\n\n    let closingNotifier;\n    try {\n      const { closingSelector } = this;\n      closingNotifier = closingSelector();\n    } catch (e) {\n      this.destination.error(e);\n      this.window.error(e);\n      return;\n    }\n    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));\n  }\n}\n"],"mappings":"AAGA,SAASA,OAAO,QAAQ,YAAY;AAEpC,SAASC,eAAe,QAAQ,oBAAoB;AAEpD,SAASC,iBAAiB,QAAQ,2BAA2B;AAgD7D,OAAM,SAAUC,UAAUA,CAAIC,eAAsC;EAClE,OAAO,SAASC,0BAA0BA,CAACC,MAAqB;IAC9D,OAAOA,MAAM,CAACC,IAAI,CAAC,IAAIC,cAAc,CAAIJ,eAAe,CAAC,CAAC;EAC5D,CAAC;AACH;AAEA,MAAMI,cAAc;EAClBC,YAAoBL,eAAsC;IAAtC,KAAAA,eAAe,GAAfA,eAAe;EACnC;EAEAM,IAAIA,CAACC,UAAqC,EAAEL,MAAW;IACrD,OAAOA,MAAM,CAACM,SAAS,CAAC,IAAIC,gBAAgB,CAACF,UAAU,EAAE,IAAI,CAACP,eAAe,CAAC,CAAC;EACjF;;AAQF,MAAMS,gBAAoB,SAAQZ,eAAuB;EAIvDQ,YAAsBK,WAAsC,EACxCV,eAAsC;IACxD,KAAK,CAACU,WAAW,CAAC;IAFE,KAAAA,WAAW,GAAXA,WAAW;IACb,KAAAV,eAAe,GAAfA,eAAe;IAEjC,IAAI,CAACW,UAAU,EAAE;EACnB;EAEAC,UAAUA,CAACC,WAAc,EAAEC,WAAgB,EAChCC,WAAmB,EAAEC,WAAmB,EACxCC,QAAiC;IAC1C,IAAI,CAACN,UAAU,CAACM,QAAQ,CAAC;EAC3B;EAEAC,WAAWA,CAACC,KAAU;IACpB,IAAI,CAACC,MAAM,CAACD,KAAK,CAAC;EACpB;EAEAE,cAAcA,CAACJ,QAAiC;IAC9C,IAAI,CAACN,UAAU,CAACM,QAAQ,CAAC;EAC3B;EAEUK,KAAKA,CAACC,KAAQ;IACtB,IAAI,CAACC,MAAO,CAACC,IAAI,CAACF,KAAK,CAAC;EAC1B;EAEUH,MAAMA,CAACM,GAAQ;IACvB,IAAI,CAACF,MAAO,CAACL,KAAK,CAACO,GAAG,CAAC;IACvB,IAAI,CAAChB,WAAW,CAACS,KAAK,CAACO,GAAG,CAAC;IAC3B,IAAI,CAACC,8BAA8B,EAAE;EACvC;EAEUC,SAASA,CAAA;IACjB,IAAI,CAACJ,MAAO,CAACK,QAAQ,EAAE;IACvB,IAAI,CAACnB,WAAW,CAACmB,QAAQ,EAAE;IAC3B,IAAI,CAACF,8BAA8B,EAAE;EACvC;EAEQA,8BAA8BA,CAAA;IACpC,IAAI,IAAI,CAACG,mBAAmB,EAAE;MAC5B,IAAI,CAACA,mBAAmB,CAACC,WAAW,EAAE;;EAE1C;EAEQpB,UAAUA,CAACM,QAAA,GAA2C,IAAI;IAChE,IAAIA,QAAQ,EAAE;MACZ,IAAI,CAACe,MAAM,CAACf,QAAQ,CAAC;MACrBA,QAAQ,CAACc,WAAW,EAAE;;IAGxB,MAAME,UAAU,GAAG,IAAI,CAACT,MAAM;IAC9B,IAAIS,UAAU,EAAE;MACdA,UAAU,CAACJ,QAAQ,EAAE;;IAGvB,MAAML,MAAM,GAAG,IAAI,CAACA,MAAM,GAAG,IAAI5B,OAAO,EAAK;IAC7C,IAAI,CAACc,WAAW,CAACe,IAAI,CAACD,MAAM,CAAC;IAE7B,IAAIU,eAAe;IACnB,IAAI;MACF,MAAM;QAAElC;MAAe,CAAE,GAAG,IAAI;MAChCkC,eAAe,GAAGlC,eAAe,EAAE;KACpC,CAAC,OAAOmC,CAAC,EAAE;MACV,IAAI,CAACzB,WAAW,CAACS,KAAK,CAACgB,CAAC,CAAC;MACzB,IAAI,CAACX,MAAM,CAACL,KAAK,CAACgB,CAAC,CAAC;MACpB;;IAEF,IAAI,CAACC,GAAG,CAAC,IAAI,CAACN,mBAAmB,GAAGhC,iBAAiB,CAAC,IAAI,EAAEoC,eAAe,CAAC,CAAC;EAC/E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}