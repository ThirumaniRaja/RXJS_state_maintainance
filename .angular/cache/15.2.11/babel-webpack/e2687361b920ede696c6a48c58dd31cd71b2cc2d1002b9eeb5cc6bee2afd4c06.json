{"ast":null,"code":"import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { isFunction } from '../util/isFunction';\nimport { map } from '../operators/map';\nconst toString = (() => Object.prototype.toString)();\nexport function fromEvent(target, eventName, options, resultSelector) {\n  if (isFunction(options)) {\n    resultSelector = options;\n    options = undefined;\n  }\n  if (resultSelector) {\n    return fromEvent(target, eventName, options).pipe(map(args => isArray(args) ? resultSelector(...args) : resultSelector(args)));\n  }\n  return new Observable(subscriber => {\n    function handler(e) {\n      if (arguments.length > 1) {\n        subscriber.next(Array.prototype.slice.call(arguments));\n      } else {\n        subscriber.next(e);\n      }\n    }\n    setupSubscription(target, eventName, handler, subscriber, options);\n  });\n}\nfunction setupSubscription(sourceObj, eventName, handler, subscriber, options) {\n  let unsubscribe;\n  if (isEventTarget(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.addEventListener(eventName, handler, options);\n    unsubscribe = () => source.removeEventListener(eventName, handler, options);\n  } else if (isJQueryStyleEventEmitter(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.on(eventName, handler);\n    unsubscribe = () => source.off(eventName, handler);\n  } else if (isNodeStyleEventEmitter(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.addListener(eventName, handler);\n    unsubscribe = () => source.removeListener(eventName, handler);\n  } else if (sourceObj && sourceObj.length) {\n    for (let i = 0, len = sourceObj.length; i < len; i++) {\n      setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n    }\n  } else {\n    throw new TypeError('Invalid event target');\n  }\n  subscriber.add(unsubscribe);\n}\nfunction isNodeStyleEventEmitter(sourceObj) {\n  return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n  return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isEventTarget(sourceObj) {\n  return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}","map":{"version":3,"names":["Observable","isArray","isFunction","map","toString","Object","prototype","fromEvent","target","eventName","options","resultSelector","undefined","pipe","args","subscriber","handler","e","arguments","length","next","Array","slice","call","setupSubscription","sourceObj","unsubscribe","isEventTarget","source","addEventListener","removeEventListener","isJQueryStyleEventEmitter","on","off","isNodeStyleEventEmitter","addListener","removeListener","i","len","TypeError","add"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\observable\\fromEvent.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { isFunction } from '../util/isFunction';\nimport { Subscriber } from '../Subscriber';\nimport { map } from '../operators/map';\n\nconst toString: Function = (() => Object.prototype.toString)();\n\nexport interface NodeStyleEventEmitter {\n  addListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n  removeListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n}\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\n// For APIs that implement `addListener` and `removeListener` methods that may\n// not use the same arguments or return EventEmitter values\n// such as React Native\nexport interface NodeCompatibleEventEmitter {\n  addListener: (eventName: string, handler: NodeEventHandler) => void | {};\n  removeListener: (eventName: string, handler: NodeEventHandler) => void | {};\n}\n\nexport interface JQueryStyleEventEmitter {\n  on: (eventName: string, handler: Function) => void;\n  off: (eventName: string, handler: Function) => void;\n}\n\nexport interface HasEventTargetAddRemove<E> {\n  addEventListener(type: string, listener: ((evt: E) => void) | null, options?: boolean | AddEventListenerOptions): void;\n  removeEventListener(type: string, listener?: ((evt: E) => void) | null, options?: EventListenerOptions | boolean): void;\n}\n\nexport type EventTargetLike<T> = HasEventTargetAddRemove<T> | NodeStyleEventEmitter | NodeCompatibleEventEmitter | JQueryStyleEventEmitter;\n\nexport type FromEventTarget<T> = EventTargetLike<T> | ArrayLike<EventTargetLike<T>>;\n\nexport interface EventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n}\n\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\n/* tslint:disable:max-line-length */\nexport function fromEvent<T>(target: FromEventTarget<T>, eventName: string): Observable<T>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function fromEvent<T>(target: FromEventTarget<T>, eventName: string, resultSelector: (...args: any[]) => T): Observable<T>;\nexport function fromEvent<T>(target: FromEventTarget<T>, eventName: string, options: EventListenerOptions): Observable<T>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function fromEvent<T>(target: FromEventTarget<T>, eventName: string, options: EventListenerOptions, resultSelector: (...args: any[]) => T): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an Observable that emits events of a specific type coming from the\n * given event target.\n *\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n * EventEmitter events or others.</span>\n *\n * ![](fromEvent.png)\n *\n * `fromEvent` accepts as a first argument event target, which is an object with methods\n * for registering event handler functions. As a second argument it takes string that indicates\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n * which are described in detail below. If your event target does not match any of the ones listed,\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n * handler functions have different names, but they all accept a string describing event type\n * and function itself, which will be called whenever said event happens.\n *\n * Every time resulting Observable is subscribed, event handler function will be registered\n * to event target on given event type. When that event fires, value\n * passed as a first argument to registered function will be emitted by output Observable.\n * When Observable is unsubscribed, function will be unregistered from event target.\n *\n * Note that if event target calls registered function with more than one argument, second\n * and following arguments will not appear in resulting stream. In order to get access to them,\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\n * passed to event handler. Output Observable will then emit value returned by project function,\n * instead of the usual value.\n *\n * Remember that event targets listed below are checked via duck typing. It means that\n * no matter what kind of object you have and no matter what environment you work in,\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\n * of course they behave as was described above). So for example if Node.js library exposes\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n * a good choice.\n *\n * If the API you use is more callback then event handler oriented (subscribed\n * callback function fires only once and thus there is no need to manually\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n * instead.\n *\n * `fromEvent` supports following types of event targets:\n *\n * **DOM EventTarget**\n *\n * This is an object with `addEventListener` and `removeEventListener` methods.\n *\n * In the browser, `addEventListener` accepts - apart from event type string and event\n * handler function arguments - optional third parameter, which is either an object or boolean,\n * both used for additional configuration how and when passed function will be called. When\n * `fromEvent` is used with event target of that type, you can provide this values\n * as third parameter as well.\n *\n * **Node.js EventEmitter**\n *\n * An object with `addListener` and `removeListener` methods.\n *\n * **JQuery-style event target**\n *\n * An object with `on` and `off` methods\n *\n * **DOM NodeList**\n *\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n *\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n * it contains and install event handler function in every of them. When returned Observable\n * is unsubscribed, function will be removed from all Nodes.\n *\n * **DOM HtmlCollection**\n *\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n * installed and removed in each of elements.\n *\n *\n * ## Examples\n * ### Emits clicks happening on the DOM document\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * clicks.subscribe(x => console.log(x));\n *\n * // Results in:\n * // MouseEvent object logged to console every time a click\n * // occurs on the document.\n * ```\n *\n * ### Use addEventListener with capture option\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const clicksInDocument = fromEvent(document, 'click', true); // note optional configuration parameter\n *                                                              // which will be passed to addEventListener\n * const clicksInDiv = fromEvent(someDivInDocument, 'click');\n *\n * clicksInDocument.subscribe(() => console.log('document'));\n * clicksInDiv.subscribe(() => console.log('div'));\n *\n * // By default events bubble UP in DOM tree, so normally\n * // when we would click on div in document\n * // \"div\" would be logged first and then \"document\".\n * // Since we specified optional `capture` option, document\n * // will catch event when it goes DOWN DOM tree, so console\n * // will log \"document\" and then \"div\".\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n * @see {@link fromEventPattern}\n *\n * @param {FromEventTarget<T>} target The DOM EventTarget, Node.js\n * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n * @param {string} eventName The event name of interest, being emitted by the\n * `target`.\n * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n * @return {Observable<T>}\n * @name fromEvent\n */\nexport function fromEvent<T>(\n  target: FromEventTarget<T>,\n  eventName: string,\n  options?: EventListenerOptions | ((...args: any[]) => T),\n  resultSelector?: ((...args: any[]) => T)\n): Observable<T> {\n\n  if (isFunction(options)) {\n    // DEPRECATED PATH\n    resultSelector = options;\n    options = undefined;\n  }\n  if (resultSelector) {\n    // DEPRECATED PATH\n    return fromEvent<T>(target, eventName, <EventListenerOptions | undefined>options).pipe(\n      map(args => isArray(args) ? resultSelector(...args) : resultSelector(args))\n    );\n  }\n\n  return new Observable<T>(subscriber => {\n    function handler(e: T) {\n      if (arguments.length > 1) {\n        subscriber.next(Array.prototype.slice.call(arguments));\n      } else {\n        subscriber.next(e);\n      }\n    }\n    setupSubscription(target, eventName, handler, subscriber, options as EventListenerOptions);\n  });\n}\n\nfunction setupSubscription<T>(sourceObj: FromEventTarget<T>, eventName: string,\n                              handler: (...args: any[]) => void, subscriber: Subscriber<T>,\n                              options?: EventListenerOptions) {\n  let unsubscribe: () => void;\n  if (isEventTarget(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.addEventListener(eventName, handler, options);\n    unsubscribe = () => source.removeEventListener(eventName, handler, options);\n  } else if (isJQueryStyleEventEmitter(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.on(eventName, handler);\n    unsubscribe = () => source.off(eventName, handler);\n  } else if (isNodeStyleEventEmitter(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.addListener(eventName, handler as NodeEventHandler);\n    unsubscribe = () => source.removeListener(eventName, handler as NodeEventHandler);\n  } else if (sourceObj && (sourceObj as any).length) {\n    for (let i = 0, len = (sourceObj as any).length; i < len; i++) {\n      setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n    }\n  } else {\n    throw new TypeError('Invalid event target');\n  }\n\n  subscriber.add(unsubscribe);\n}\n\nfunction isNodeStyleEventEmitter(sourceObj: any): sourceObj is NodeStyleEventEmitter {\n  return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\n\nfunction isJQueryStyleEventEmitter(sourceObj: any): sourceObj is JQueryStyleEventEmitter {\n  return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\n\nfunction isEventTarget(sourceObj: any): sourceObj is HasEventTargetAddRemove<any> {\n  return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,eAAe;AAC1C,SAASC,OAAO,QAAQ,iBAAiB;AACzC,SAASC,UAAU,QAAQ,oBAAoB;AAE/C,SAASC,GAAG,QAAQ,kBAAkB;AAEtC,MAAMC,QAAQ,GAAa,CAAC,MAAMC,MAAM,CAACC,SAAS,CAACF,QAAQ,EAAC,CAAE;AA0K9D,OAAM,SAAUG,SAASA,CACvBC,MAA0B,EAC1BC,SAAiB,EACjBC,OAAwD,EACxDC,cAAwC;EAGxC,IAAIT,UAAU,CAACQ,OAAO,CAAC,EAAE;IAEvBC,cAAc,GAAGD,OAAO;IACxBA,OAAO,GAAGE,SAAS;;EAErB,IAAID,cAAc,EAAE;IAElB,OAAOJ,SAAS,CAAIC,MAAM,EAAEC,SAAS,EAAoCC,OAAO,CAAC,CAACG,IAAI,CACpFV,GAAG,CAACW,IAAI,IAAIb,OAAO,CAACa,IAAI,CAAC,GAAGH,cAAc,CAAC,GAAGG,IAAI,CAAC,GAAGH,cAAc,CAACG,IAAI,CAAC,CAAC,CAC5E;;EAGH,OAAO,IAAId,UAAU,CAAIe,UAAU,IAAG;IACpC,SAASC,OAAOA,CAACC,CAAI;MACnB,IAAIC,SAAS,CAACC,MAAM,GAAG,CAAC,EAAE;QACxBJ,UAAU,CAACK,IAAI,CAACC,KAAK,CAACf,SAAS,CAACgB,KAAK,CAACC,IAAI,CAACL,SAAS,CAAC,CAAC;OACvD,MAAM;QACLH,UAAU,CAACK,IAAI,CAACH,CAAC,CAAC;;IAEtB;IACAO,iBAAiB,CAAChB,MAAM,EAAEC,SAAS,EAAEO,OAAO,EAAED,UAAU,EAAEL,OAA+B,CAAC;EAC5F,CAAC,CAAC;AACJ;AAEA,SAASc,iBAAiBA,CAAIC,SAA6B,EAAEhB,SAAiB,EAChDO,OAAiC,EAAED,UAAyB,EAC5DL,OAA8B;EAC1D,IAAIgB,WAAuB;EAC3B,IAAIC,aAAa,CAACF,SAAS,CAAC,EAAE;IAC5B,MAAMG,MAAM,GAAGH,SAAS;IACxBA,SAAS,CAACI,gBAAgB,CAACpB,SAAS,EAAEO,OAAO,EAAEN,OAAO,CAAC;IACvDgB,WAAW,GAAGA,CAAA,KAAME,MAAM,CAACE,mBAAmB,CAACrB,SAAS,EAAEO,OAAO,EAAEN,OAAO,CAAC;GAC5E,MAAM,IAAIqB,yBAAyB,CAACN,SAAS,CAAC,EAAE;IAC/C,MAAMG,MAAM,GAAGH,SAAS;IACxBA,SAAS,CAACO,EAAE,CAACvB,SAAS,EAAEO,OAAO,CAAC;IAChCU,WAAW,GAAGA,CAAA,KAAME,MAAM,CAACK,GAAG,CAACxB,SAAS,EAAEO,OAAO,CAAC;GACnD,MAAM,IAAIkB,uBAAuB,CAACT,SAAS,CAAC,EAAE;IAC7C,MAAMG,MAAM,GAAGH,SAAS;IACxBA,SAAS,CAACU,WAAW,CAAC1B,SAAS,EAAEO,OAA2B,CAAC;IAC7DU,WAAW,GAAGA,CAAA,KAAME,MAAM,CAACQ,cAAc,CAAC3B,SAAS,EAAEO,OAA2B,CAAC;GAClF,MAAM,IAAIS,SAAS,IAAKA,SAAiB,CAACN,MAAM,EAAE;IACjD,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAIb,SAAiB,CAACN,MAAM,EAAEkB,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC7Db,iBAAiB,CAACC,SAAS,CAACY,CAAC,CAAC,EAAE5B,SAAS,EAAEO,OAAO,EAAED,UAAU,EAAEL,OAAO,CAAC;;GAE3E,MAAM;IACL,MAAM,IAAI6B,SAAS,CAAC,sBAAsB,CAAC;;EAG7CxB,UAAU,CAACyB,GAAG,CAACd,WAAW,CAAC;AAC7B;AAEA,SAASQ,uBAAuBA,CAACT,SAAc;EAC7C,OAAOA,SAAS,IAAI,OAAOA,SAAS,CAACU,WAAW,KAAK,UAAU,IAAI,OAAOV,SAAS,CAACW,cAAc,KAAK,UAAU;AACnH;AAEA,SAASL,yBAAyBA,CAACN,SAAc;EAC/C,OAAOA,SAAS,IAAI,OAAOA,SAAS,CAACO,EAAE,KAAK,UAAU,IAAI,OAAOP,SAAS,CAACQ,GAAG,KAAK,UAAU;AAC/F;AAEA,SAASN,aAAaA,CAACF,SAAc;EACnC,OAAOA,SAAS,IAAI,OAAOA,SAAS,CAACI,gBAAgB,KAAK,UAAU,IAAI,OAAOJ,SAAS,CAACK,mBAAmB,KAAK,UAAU;AAC7H","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}