{"ast":null,"code":"import { map } from './map';\nimport { from } from '../observable/from';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\nexport function switchMap(project, resultSelector) {\n  if (typeof resultSelector === 'function') {\n    return source => source.pipe(switchMap((a, i) => from(project(a, i)).pipe(map((b, ii) => resultSelector(a, b, i, ii)))));\n  }\n  return source => source.lift(new SwitchMapOperator(project));\n}\nclass SwitchMapOperator {\n  constructor(project) {\n    this.project = project;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));\n  }\n}\nclass SwitchMapSubscriber extends SimpleOuterSubscriber {\n  constructor(destination, project) {\n    super(destination);\n    this.project = project;\n    this.index = 0;\n  }\n  _next(value) {\n    let result;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (error) {\n      this.destination.error(error);\n      return;\n    }\n    this._innerSub(result);\n  }\n  _innerSub(result) {\n    const innerSubscription = this.innerSubscription;\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    const destination = this.destination;\n    destination.add(innerSubscriber);\n    this.innerSubscription = innerSubscribe(result, innerSubscriber);\n    if (this.innerSubscription !== innerSubscriber) {\n      destination.add(this.innerSubscription);\n    }\n  }\n  _complete() {\n    const {\n      innerSubscription\n    } = this;\n    if (!innerSubscription || innerSubscription.closed) {\n      super._complete();\n    }\n    this.unsubscribe();\n  }\n  _unsubscribe() {\n    this.innerSubscription = undefined;\n  }\n  notifyComplete() {\n    this.innerSubscription = undefined;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n  notifyNext(innerValue) {\n    this.destination.next(innerValue);\n  }\n}","map":{"version":3,"names":["map","from","SimpleOuterSubscriber","SimpleInnerSubscriber","innerSubscribe","switchMap","project","resultSelector","source","pipe","a","i","b","ii","lift","SwitchMapOperator","constructor","call","subscriber","subscribe","SwitchMapSubscriber","destination","index","_next","value","result","error","_innerSub","innerSubscription","unsubscribe","innerSubscriber","add","_complete","closed","_unsubscribe","undefined","notifyComplete","isStopped","notifyNext","innerValue","next"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\switchMap.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { from } from '../observable/from';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport function switchMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport function switchMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables.</span>\n *\n * ![](switchMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * ## Example\n * Generate new Observable according to source Observable values\n * ```typescript\n * import { of } from 'rxjs';\n * import { switchMap } from 'rxjs/operators';\n *\n * const switched = of(1, 2, 3).pipe(switchMap((x: number) => of(x, x ** 2, x ** 3)));\n * switched.subscribe(x => console.log(x));\n * // outputs\n * // 1\n * // 1\n * // 1\n * // 2\n * // 4\n * // 8\n * // ... and so on\n * ```\n *\n * Rerun an interval Observable on every click event\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { switchMap } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMap((ev) => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchAll}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional deprecated `resultSelector`) to each item\n * emitted by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  if (typeof resultSelector === 'function') {\n    return (source: Observable<T>) => source.pipe(\n      switchMap((a, i) => from(project(a, i)).pipe(\n        map((b, ii) => resultSelector(a, b, i, ii))\n      ))\n    );\n  }\n  return (source: Observable<T>) => source.lift(new SwitchMapOperator(project));\n}\n\nclass SwitchMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchMapSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private index = 0;\n  private innerSubscription?: Subscription;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    let result: ObservableInput<R>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (error) {\n      this.destination.error!(error);\n      return;\n    }\n    this._innerSub(result);\n  }\n\n  private _innerSub(result: ObservableInput<R>) {\n    const innerSubscription = this.innerSubscription;\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscriber);\n    this.innerSubscription = innerSubscribe(result, innerSubscriber);\n    // The returned subscription will usually be the subscriber that was\n    // passed. However, interop subscribers will be wrapped and for\n    // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n    if (this.innerSubscription !== innerSubscriber) {\n      destination.add(this.innerSubscription);\n    }\n  }\n\n  protected _complete(): void {\n    const {innerSubscription} = this;\n    if (!innerSubscription || innerSubscription.closed) {\n      super._complete();\n    }\n    this.unsubscribe();\n  }\n\n  protected _unsubscribe() {\n    this.innerSubscription = undefined;\n  }\n\n  notifyComplete(): void {\n    this.innerSubscription = undefined;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n\n  notifyNext(innerValue: R): void {\n      this.destination.next!(innerValue);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}