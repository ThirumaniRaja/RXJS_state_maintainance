{"ast":null,"code":"import { Subject } from '../Subject';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function windowTime(windowTimeSpan) {\n  let scheduler = async;\n  let windowCreationInterval = null;\n  let maxWindowSize = Number.POSITIVE_INFINITY;\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = Number(arguments[2]);\n  }\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = Number(arguments[1]);\n  }\n  return function windowTimeOperatorFunction(source) {\n    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n  };\n}\nclass WindowTimeOperator {\n  constructor(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    this.windowTimeSpan = windowTimeSpan;\n    this.windowCreationInterval = windowCreationInterval;\n    this.maxWindowSize = maxWindowSize;\n    this.scheduler = scheduler;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n  }\n}\nclass CountedSubject extends Subject {\n  constructor() {\n    super(...arguments);\n    this._numberOfNextedValues = 0;\n  }\n  next(value) {\n    this._numberOfNextedValues++;\n    super.next(value);\n  }\n  get numberOfNextedValues() {\n    return this._numberOfNextedValues;\n  }\n}\nclass WindowTimeSubscriber extends Subscriber {\n  constructor(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    super(destination);\n    this.destination = destination;\n    this.windowTimeSpan = windowTimeSpan;\n    this.windowCreationInterval = windowCreationInterval;\n    this.maxWindowSize = maxWindowSize;\n    this.scheduler = scheduler;\n    this.windows = [];\n    const window = this.openWindow();\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      const closeState = {\n        subscriber: this,\n        window,\n        context: null\n      };\n      const creationState = {\n        windowTimeSpan,\n        windowCreationInterval,\n        subscriber: this,\n        scheduler\n      };\n      this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      const timeSpanOnlyState = {\n        subscriber: this,\n        window,\n        windowTimeSpan\n      };\n      this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n  }\n  _next(value) {\n    const windows = this.windows;\n    const len = windows.length;\n    for (let i = 0; i < len; i++) {\n      const window = windows[i];\n      if (!window.closed) {\n        window.next(value);\n        if (window.numberOfNextedValues >= this.maxWindowSize) {\n          this.closeWindow(window);\n        }\n      }\n    }\n  }\n  _error(err) {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n    this.destination.error(err);\n  }\n  _complete() {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      const window = windows.shift();\n      if (!window.closed) {\n        window.complete();\n      }\n    }\n    this.destination.complete();\n  }\n  openWindow() {\n    const window = new CountedSubject();\n    this.windows.push(window);\n    const destination = this.destination;\n    destination.next(window);\n    return window;\n  }\n  closeWindow(window) {\n    window.complete();\n    const windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  }\n}\nfunction dispatchWindowTimeSpanOnly(state) {\n  const {\n    subscriber,\n    windowTimeSpan,\n    window\n  } = state;\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n  const {\n    windowTimeSpan,\n    subscriber,\n    scheduler,\n    windowCreationInterval\n  } = state;\n  const window = subscriber.openWindow();\n  const action = this;\n  let context = {\n    action,\n    subscription: null\n  };\n  const timeSpanState = {\n    subscriber,\n    window,\n    context\n  };\n  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n  const {\n    subscriber,\n    window,\n    context\n  } = state;\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n  subscriber.closeWindow(window);\n}","map":{"version":3,"names":["Subject","async","Subscriber","isNumeric","isScheduler","windowTime","windowTimeSpan","scheduler","windowCreationInterval","maxWindowSize","Number","POSITIVE_INFINITY","arguments","windowTimeOperatorFunction","source","lift","WindowTimeOperator","constructor","call","subscriber","subscribe","WindowTimeSubscriber","CountedSubject","_numberOfNextedValues","next","value","numberOfNextedValues","destination","windows","window","openWindow","closeState","context","creationState","add","schedule","dispatchWindowClose","dispatchWindowCreation","timeSpanOnlyState","dispatchWindowTimeSpanOnly","_next","len","length","i","closed","closeWindow","_error","err","shift","error","_complete","complete","push","splice","indexOf","state","action","subscription","timeSpanState","remove"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\windowTime.ts"],"sourcesContent":["import { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nimport { OperatorFunction, SchedulerLike, SchedulerAction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowTime.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\n * will emit at most fixed number of values. Window will complete immediately\n * after emitting last value and next one still will open as specified by\n * `windowTimeSpan` and `windowCreationInterval` arguments.\n *\n * ## Examples\n * In every window of 1 second each, emit at most 2 click events\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowTime, map, mergeAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000),\n *   map(win => win.pipe(take(2))), // each window has at most 2 emissions\n *   mergeAll(),                    // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds start a window 1 second long, and emit at most 2 click events per window\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowTime, map, mergeAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000),\n *   map(win => win.pipe(take(2))), // each window has at most 2 emissions\n *   mergeAll(),                    // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Same as example above but with maxWindowCount instead of take\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowTime, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000, 2), // each window has still at most 2 emissions\n *   mergeAll(),                // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param {number} windowTimeSpan The amount of time to fill each window.\n * @param {number} [windowCreationInterval] The interval at which to start new\n * windows.\n * @param {number} [maxWindowSize=Number.POSITIVE_INFINITY] Max number of\n * values each window can emit before completion.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowTime\n * @owner Observable\n */\nexport function windowTime<T>(windowTimeSpan: number,\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              maxWindowSize: number,\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\n\nexport function windowTime<T>(windowTimeSpan: number): OperatorFunction<T, Observable<T>> {\n  let scheduler: SchedulerLike = async;\n  let windowCreationInterval: number = null;\n  let maxWindowSize: number = Number.POSITIVE_INFINITY;\n\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = Number(arguments[2]);\n  }\n\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = Number(arguments[1]);\n  }\n\n  return function windowTimeOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowTimeOperator<T>(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n  };\n}\n\nclass WindowTimeOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowTimeSpan: number,\n              private windowCreationInterval: number | null,\n              private maxWindowSize: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowTimeSubscriber(\n      subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler\n    ));\n  }\n}\n\ninterface CreationState<T> {\n  windowTimeSpan: number;\n  windowCreationInterval: number;\n  subscriber: WindowTimeSubscriber<T>;\n  scheduler: SchedulerLike;\n}\n\ninterface TimeSpanOnlyState<T> {\n    window: CountedSubject<T>;\n    windowTimeSpan: number;\n    subscriber: WindowTimeSubscriber<T>;\n  }\n\ninterface CloseWindowContext<T> {\n  action: SchedulerAction<CreationState<T>>;\n  subscription: Subscription;\n}\n\ninterface CloseState<T> {\n  subscriber: WindowTimeSubscriber<T>;\n  window: CountedSubject<T>;\n  context: CloseWindowContext<T>;\n}\n\nclass CountedSubject<T> extends Subject<T> {\n  private _numberOfNextedValues: number = 0;\n\n  next(value?: T): void {\n    this._numberOfNextedValues++;\n    super.next(value);\n  }\n\n  get numberOfNextedValues(): number {\n    return this._numberOfNextedValues;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowTimeSubscriber<T> extends Subscriber<T> {\n  private windows: CountedSubject<T>[] = [];\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private windowTimeSpan: number,\n              private windowCreationInterval: number | null,\n              private maxWindowSize: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n\n    const window = this.openWindow();\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      const closeState: CloseState<T> = { subscriber: this, window, context: <any>null };\n      const creationState: CreationState<T> = { windowTimeSpan, windowCreationInterval, subscriber: this, scheduler };\n      this.add(scheduler.schedule<CloseState<T>>(dispatchWindowClose, windowTimeSpan, closeState));\n      this.add(scheduler.schedule<CreationState<T>>(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      const timeSpanOnlyState: TimeSpanOnlyState<T> = { subscriber: this, window, windowTimeSpan };\n      this.add(scheduler.schedule<TimeSpanOnlyState<T>>(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  protected _next(value: T): void {\n    const windows = this.windows;\n    const len = windows.length;\n    for (let i = 0; i < len; i++) {\n      const window = windows[i];\n      if (!window.closed) {\n        window.next(value);\n        if (window.numberOfNextedValues >= this.maxWindowSize) {\n          this.closeWindow(window);\n        }\n      }\n    }\n  }\n\n  protected _error(err: any): void {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete(): void {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      const window = windows.shift();\n      if (!window.closed) {\n        window.complete();\n      }\n    }\n    this.destination.complete();\n  }\n\n  public openWindow(): CountedSubject<T> {\n    const window = new CountedSubject<T>();\n    this.windows.push(window);\n    const destination = this.destination;\n    destination.next(window);\n    return window;\n  }\n\n  public closeWindow(window: CountedSubject<T>): void {\n    window.complete();\n    const windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  }\n}\n\nfunction dispatchWindowTimeSpanOnly<T>(this: SchedulerAction<TimeSpanOnlyState<T>>, state: TimeSpanOnlyState<T>): void {\n  const { subscriber, windowTimeSpan, window } = state;\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\n\nfunction dispatchWindowCreation<T>(this: SchedulerAction<CreationState<T>>, state: CreationState<T>): void {\n  const { windowTimeSpan, subscriber, scheduler, windowCreationInterval } = state;\n  const window = subscriber.openWindow();\n  const action = this;\n  let context: CloseWindowContext<T> = { action, subscription: <any>null };\n  const timeSpanState: CloseState<T> = { subscriber, window, context };\n  context.subscription = scheduler.schedule<CloseState<T>>(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\n\nfunction dispatchWindowClose<T>(state: CloseState<T>): void {\n  const { subscriber, window, context } = state;\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n  subscriber.closeWindow(window);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}