{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nexport function refCount() {\n  return function refCountOperatorFunction(source) {\n    return source.lift(new RefCountOperator(source));\n  };\n}\nclass RefCountOperator {\n  constructor(connectable) {\n    this.connectable = connectable;\n  }\n  call(subscriber, source) {\n    const {\n      connectable\n    } = this;\n    connectable._refCount++;\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n    if (!refCounter.closed) {\n      refCounter.connection = connectable.connect();\n    }\n    return subscription;\n  }\n}\nclass RefCountSubscriber extends Subscriber {\n  constructor(destination, connectable) {\n    super(destination);\n    this.connectable = connectable;\n  }\n  _unsubscribe() {\n    const {\n      connectable\n    } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n    this.connectable = null;\n    const refCount = connectable._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n    connectable._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n    const {\n      connection\n    } = this;\n    const sharedConnection = connectable._connection;\n    this.connection = null;\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}","map":{"version":3,"names":["Subscriber","refCount","refCountOperatorFunction","source","lift","RefCountOperator","constructor","connectable","call","subscriber","_refCount","refCounter","RefCountSubscriber","subscription","subscribe","closed","connection","connect","destination","_unsubscribe","sharedConnection","_connection","unsubscribe"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\refCount.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Observable } from '../Observable';\n\n/**\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\n * you can connect to it.\n *\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\n * unsubscribes from the source. This way you can make sure that everything before the *published*\n * refCount has only a single subscription independently of the number of subscribers to the target\n * observable.\n *\n * Note that using the {@link share} operator is exactly the same as using the *publish* operator\n * (making the observable hot) and the *refCount* operator in a sequence.\n *\n * ![](refCount.png)\n *\n * ## Example\n *\n * In the following example there are two intervals turned into connectable observables\n * by using the *publish* operator. The first one uses the *refCount* operator, the\n * second one does not use it. You will notice that a connectable observable does nothing\n * until you call its connect function.\n *\n * ```ts\n * import { interval } from 'rxjs';\n * import { tap, publish, refCount } from 'rxjs/operators';\n *\n * // Turn the interval observable into a ConnectableObservable (hot)\n * const refCountInterval = interval(400).pipe(\n *   tap((num) => console.log(`refCount ${num}`)),\n *   publish(),\n *   refCount()\n * );\n *\n * const publishedInterval = interval(400).pipe(\n *   tap((num) => console.log(`publish ${num}`)),\n *   publish()\n * );\n *\n * refCountInterval.subscribe();\n * refCountInterval.subscribe();\n * // 'refCount 0' -----> 'refCount 1' -----> etc\n * // All subscriptions will receive the same value and the tap (and\n * // every other operator) before the publish operator will be executed\n * // only once per event independently of the number of subscriptions.\n *\n * publishedInterval.subscribe();\n * // Nothing happens until you call .connect() on the observable.\n * ```\n *\n * @see {@link ConnectableObservable}\n * @see {@link share}\n * @see {@link publish}\n */\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return function refCountOperatorFunction(source: ConnectableObservable<T>): Observable<T> {\n    return source.lift(new RefCountOperator(source));\n  } as MonoTypeOperatorFunction<T>;\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // )\n    // .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n"],"mappings":"AACA,SAASA,UAAU,QAAQ,eAAe;AA2D1C,OAAM,SAAUC,QAAQA,CAAA;EACtB,OAAO,SAASC,wBAAwBA,CAACC,MAAgC;IACvE,OAAOA,MAAM,CAACC,IAAI,CAAC,IAAIC,gBAAgB,CAACF,MAAM,CAAC,CAAC;EAClD,CAAgC;AAClC;AAEA,MAAME,gBAAgB;EACpBC,YAAoBC,WAAqC;IAArC,KAAAA,WAAW,GAAXA,WAAW;EAC/B;EACAC,IAAIA,CAACC,UAAyB,EAAEN,MAAW;IAEzC,MAAM;MAAEI;IAAW,CAAE,GAAG,IAAI;IACrBA,WAAY,CAACG,SAAS,EAAE;IAE/B,MAAMC,UAAU,GAAG,IAAIC,kBAAkB,CAACH,UAAU,EAAEF,WAAW,CAAC;IAClE,MAAMM,YAAY,GAAGV,MAAM,CAACW,SAAS,CAACH,UAAU,CAAC;IAEjD,IAAI,CAACA,UAAU,CAACI,MAAM,EAAE;MACfJ,UAAW,CAACK,UAAU,GAAGT,WAAW,CAACU,OAAO,EAAE;;IAGvD,OAAOJ,YAAY;EACrB;;AAGF,MAAMD,kBAAsB,SAAQZ,UAAa;EAI/CM,YAAYY,WAA0B,EAClBX,WAAqC;IACvD,KAAK,CAACW,WAAW,CAAC;IADA,KAAAX,WAAW,GAAXA,WAAW;EAE/B;EAEUY,YAAYA,CAAA;IAEpB,MAAM;MAAEZ;IAAW,CAAE,GAAG,IAAI;IAC5B,IAAI,CAACA,WAAW,EAAE;MAChB,IAAI,CAACS,UAAU,GAAG,IAAI;MACtB;;IAGF,IAAI,CAACT,WAAW,GAAG,IAAI;IACvB,MAAMN,QAAQ,GAAUM,WAAY,CAACG,SAAS;IAC9C,IAAIT,QAAQ,IAAI,CAAC,EAAE;MACjB,IAAI,CAACe,UAAU,GAAG,IAAI;MACtB;;IAGKT,WAAY,CAACG,SAAS,GAAGT,QAAQ,GAAG,CAAC;IAC5C,IAAIA,QAAQ,GAAG,CAAC,EAAE;MAChB,IAAI,CAACe,UAAU,GAAG,IAAI;MACtB;;IA2BF,MAAM;MAAEA;IAAU,CAAE,GAAG,IAAI;IAC3B,MAAMI,gBAAgB,GAAUb,WAAY,CAACc,WAAW;IACxD,IAAI,CAACL,UAAU,GAAG,IAAI;IAEtB,IAAII,gBAAgB,KAAK,CAACJ,UAAU,IAAII,gBAAgB,KAAKJ,UAAU,CAAC,EAAE;MACxEI,gBAAgB,CAACE,WAAW,EAAE;;EAElC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}