{"ast":null,"code":"import { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport class ReplaySubject extends Subject {\n  constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {\n    super();\n    this.scheduler = scheduler;\n    this._events = [];\n    this._infiniteTimeWindow = false;\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      this._infiniteTimeWindow = true;\n      this.next = this.nextInfiniteTimeWindow;\n    } else {\n      this.next = this.nextTimeWindow;\n    }\n  }\n  nextInfiniteTimeWindow(value) {\n    if (!this.isStopped) {\n      const _events = this._events;\n      _events.push(value);\n      if (_events.length > this._bufferSize) {\n        _events.shift();\n      }\n    }\n    super.next(value);\n  }\n  nextTimeWindow(value) {\n    if (!this.isStopped) {\n      this._events.push(new ReplayEvent(this._getNow(), value));\n      this._trimBufferThenGetEvents();\n    }\n    super.next(value);\n  }\n  _subscribe(subscriber) {\n    const _infiniteTimeWindow = this._infiniteTimeWindow;\n    const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n    const scheduler = this.scheduler;\n    const len = _events.length;\n    let subscription;\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n    }\n    if (_infiniteTimeWindow) {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i]);\n      }\n    } else {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i].value);\n      }\n    }\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n    return subscription;\n  }\n  _getNow() {\n    return (this.scheduler || queue).now();\n  }\n  _trimBufferThenGetEvents() {\n    const now = this._getNow();\n    const _bufferSize = this._bufferSize;\n    const _windowTime = this._windowTime;\n    const _events = this._events;\n    const eventsCount = _events.length;\n    let spliceCount = 0;\n    while (spliceCount < eventsCount) {\n      if (now - _events[spliceCount].time < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n    return _events;\n  }\n}\nclass ReplayEvent {\n  constructor(time, value) {\n    this.time = time;\n    this.value = value;\n  }\n}","map":{"version":3,"names":["Subject","queue","Subscription","ObserveOnSubscriber","ObjectUnsubscribedError","SubjectSubscription","ReplaySubject","constructor","bufferSize","Number","POSITIVE_INFINITY","windowTime","scheduler","_events","_infiniteTimeWindow","_bufferSize","_windowTime","next","nextInfiniteTimeWindow","nextTimeWindow","value","isStopped","push","length","shift","ReplayEvent","_getNow","_trimBufferThenGetEvents","_subscribe","subscriber","len","subscription","closed","hasError","EMPTY","observers","add","i","error","thrownError","complete","now","eventsCount","spliceCount","time","Math","max","splice"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\ReplaySubject.ts"],"sourcesContent":["import { Subject } from './Subject';\nimport { SchedulerLike } from './types';\nimport { queue } from './scheduler/queue';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\n/**\n * A variant of Subject that \"replays\" or emits old values to new subscribers.\n * It buffers a set number of values and will emit those values immediately to\n * any new subscribers in addition to emitting new values to existing subscribers.\n *\n * @class ReplaySubject<T>\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _events: (ReplayEvent<T> | T)[] = [];\n  private _bufferSize: number;\n  private _windowTime: number;\n  private _infiniteTimeWindow: boolean = false;\n\n  constructor(bufferSize: number = Number.POSITIVE_INFINITY,\n              windowTime: number = Number.POSITIVE_INFINITY,\n              private scheduler?: SchedulerLike) {\n    super();\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      this._infiniteTimeWindow = true;\n      this.next = this.nextInfiniteTimeWindow;\n    } else {\n      this.next = this.nextTimeWindow;\n    }\n  }\n\n  private nextInfiniteTimeWindow(value: T): void {\n    if (!this.isStopped) {\n      const _events = this._events;\n      _events.push(value);\n      // Since this method is invoked in every next() call than the buffer\n      // can overgrow the max size only by one item\n      if (_events.length > this._bufferSize) {\n        _events.shift();\n      }\n    }\n    super.next(value);\n  }\n\n  private nextTimeWindow(value: T): void {\n    if (!this.isStopped) {\n      this._events.push(new ReplayEvent(this._getNow(), value));\n      this._trimBufferThenGetEvents();\n    }\n    super.next(value);\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    // When `_infiniteTimeWindow === true` then the buffer is already trimmed\n    const _infiniteTimeWindow = this._infiniteTimeWindow;\n    const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n    const scheduler = this.scheduler;\n    const len = _events.length;\n    let subscription: Subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber<T>(subscriber, scheduler));\n    }\n\n    if (_infiniteTimeWindow) {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(<T>_events[i]);\n      }\n    } else {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next((<ReplayEvent<T>>_events[i]).value);\n      }\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  }\n\n  _getNow(): number {\n    return (this.scheduler || queue).now();\n  }\n\n  private _trimBufferThenGetEvents(): ReplayEvent<T>[] {\n    const now = this._getNow();\n    const _bufferSize = this._bufferSize;\n    const _windowTime = this._windowTime;\n    const _events = <ReplayEvent<T>[]>this._events;\n\n    const eventsCount = _events.length;\n    let spliceCount = 0;\n\n    // Trim events that fall out of the time window.\n    // Start at the front of the list. Break early once\n    // we encounter an event that falls within the window.\n    while (spliceCount < eventsCount) {\n      if ((now - _events[spliceCount].time) < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  }\n\n}\n\nclass ReplayEvent<T> {\n  constructor(public time: number, public value: T) {\n  }\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,WAAW;AAEnC,SAASC,KAAK,QAAQ,mBAAmB;AAEzC,SAASC,YAAY,QAAQ,gBAAgB;AAC7C,SAASC,mBAAmB,QAAQ,uBAAuB;AAC3D,SAASC,uBAAuB,QAAQ,gCAAgC;AACxE,SAASC,mBAAmB,QAAQ,uBAAuB;AAQ3D,OAAM,MAAOC,aAAiB,SAAQN,OAAU;EAM9CO,YAAYC,UAAA,GAAqBC,MAAM,CAACC,iBAAiB,EAC7CC,UAAA,GAAqBF,MAAM,CAACC,iBAAiB,EACrCE,SAAyB;IAC3C,KAAK,EAAE;IADW,KAAAA,SAAS,GAATA,SAAS;IAPrB,KAAAC,OAAO,GAA2B,EAAE;IAGpC,KAAAC,mBAAmB,GAAY,KAAK;IAM1C,IAAI,CAACC,WAAW,GAAGP,UAAU,GAAG,CAAC,GAAG,CAAC,GAAGA,UAAU;IAClD,IAAI,CAACQ,WAAW,GAAGL,UAAU,GAAG,CAAC,GAAG,CAAC,GAAGA,UAAU;IAElD,IAAIA,UAAU,KAAKF,MAAM,CAACC,iBAAiB,EAAE;MAC3C,IAAI,CAACI,mBAAmB,GAAG,IAAI;MAC/B,IAAI,CAACG,IAAI,GAAG,IAAI,CAACC,sBAAsB;KACxC,MAAM;MACL,IAAI,CAACD,IAAI,GAAG,IAAI,CAACE,cAAc;;EAEnC;EAEQD,sBAAsBA,CAACE,KAAQ;IACrC,IAAI,CAAC,IAAI,CAACC,SAAS,EAAE;MACnB,MAAMR,OAAO,GAAG,IAAI,CAACA,OAAO;MAC5BA,OAAO,CAACS,IAAI,CAACF,KAAK,CAAC;MAGnB,IAAIP,OAAO,CAACU,MAAM,GAAG,IAAI,CAACR,WAAW,EAAE;QACrCF,OAAO,CAACW,KAAK,EAAE;;;IAGnB,KAAK,CAACP,IAAI,CAACG,KAAK,CAAC;EACnB;EAEQD,cAAcA,CAACC,KAAQ;IAC7B,IAAI,CAAC,IAAI,CAACC,SAAS,EAAE;MACnB,IAAI,CAACR,OAAO,CAACS,IAAI,CAAC,IAAIG,WAAW,CAAC,IAAI,CAACC,OAAO,EAAE,EAAEN,KAAK,CAAC,CAAC;MACzD,IAAI,CAACO,wBAAwB,EAAE;;IAEjC,KAAK,CAACV,IAAI,CAACG,KAAK,CAAC;EACnB;EAGAQ,UAAUA,CAACC,UAAyB;IAElC,MAAMf,mBAAmB,GAAG,IAAI,CAACA,mBAAmB;IACpD,MAAMD,OAAO,GAAGC,mBAAmB,GAAG,IAAI,CAACD,OAAO,GAAG,IAAI,CAACc,wBAAwB,EAAE;IACpF,MAAMf,SAAS,GAAG,IAAI,CAACA,SAAS;IAChC,MAAMkB,GAAG,GAAGjB,OAAO,CAACU,MAAM;IAC1B,IAAIQ,YAA0B;IAE9B,IAAI,IAAI,CAACC,MAAM,EAAE;MACf,MAAM,IAAI5B,uBAAuB,EAAE;KACpC,MAAM,IAAI,IAAI,CAACiB,SAAS,IAAI,IAAI,CAACY,QAAQ,EAAE;MAC1CF,YAAY,GAAG7B,YAAY,CAACgC,KAAK;KAClC,MAAM;MACL,IAAI,CAACC,SAAS,CAACb,IAAI,CAACO,UAAU,CAAC;MAC/BE,YAAY,GAAG,IAAI1B,mBAAmB,CAAC,IAAI,EAAEwB,UAAU,CAAC;;IAG1D,IAAIjB,SAAS,EAAE;MACbiB,UAAU,CAACO,GAAG,CAACP,UAAU,GAAG,IAAI1B,mBAAmB,CAAI0B,UAAU,EAAEjB,SAAS,CAAC,CAAC;;IAGhF,IAAIE,mBAAmB,EAAE;MACvB,KAAK,IAAIuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,GAAG,IAAI,CAACD,UAAU,CAACG,MAAM,EAAEK,CAAC,EAAE,EAAE;QAClDR,UAAU,CAACZ,IAAI,CAAIJ,OAAO,CAACwB,CAAC,CAAC,CAAC;;KAEjC,MAAM;MACL,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,GAAG,IAAI,CAACD,UAAU,CAACG,MAAM,EAAEK,CAAC,EAAE,EAAE;QAClDR,UAAU,CAACZ,IAAI,CAAkBJ,OAAO,CAACwB,CAAC,CAAE,CAACjB,KAAK,CAAC;;;IAIvD,IAAI,IAAI,CAACa,QAAQ,EAAE;MACjBJ,UAAU,CAACS,KAAK,CAAC,IAAI,CAACC,WAAW,CAAC;KACnC,MAAM,IAAI,IAAI,CAAClB,SAAS,EAAE;MACzBQ,UAAU,CAACW,QAAQ,EAAE;;IAGvB,OAAOT,YAAY;EACrB;EAEAL,OAAOA,CAAA;IACL,OAAO,CAAC,IAAI,CAACd,SAAS,IAAIX,KAAK,EAAEwC,GAAG,EAAE;EACxC;EAEQd,wBAAwBA,CAAA;IAC9B,MAAMc,GAAG,GAAG,IAAI,CAACf,OAAO,EAAE;IAC1B,MAAMX,WAAW,GAAG,IAAI,CAACA,WAAW;IACpC,MAAMC,WAAW,GAAG,IAAI,CAACA,WAAW;IACpC,MAAMH,OAAO,GAAqB,IAAI,CAACA,OAAO;IAE9C,MAAM6B,WAAW,GAAG7B,OAAO,CAACU,MAAM;IAClC,IAAIoB,WAAW,GAAG,CAAC;IAKnB,OAAOA,WAAW,GAAGD,WAAW,EAAE;MAChC,IAAKD,GAAG,GAAG5B,OAAO,CAAC8B,WAAW,CAAC,CAACC,IAAI,GAAI5B,WAAW,EAAE;QACnD;;MAEF2B,WAAW,EAAE;;IAGf,IAAID,WAAW,GAAG3B,WAAW,EAAE;MAC7B4B,WAAW,GAAGE,IAAI,CAACC,GAAG,CAACH,WAAW,EAAED,WAAW,GAAG3B,WAAW,CAAC;;IAGhE,IAAI4B,WAAW,GAAG,CAAC,EAAE;MACnB9B,OAAO,CAACkC,MAAM,CAAC,CAAC,EAAEJ,WAAW,CAAC;;IAGhC,OAAO9B,OAAO;EAChB;;AAIF,MAAMY,WAAW;EACflB,YAAmBqC,IAAY,EAASxB,KAAQ;IAA7B,KAAAwB,IAAI,GAAJA,IAAI;IAAiB,KAAAxB,KAAK,GAALA,KAAK;EAC7C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}