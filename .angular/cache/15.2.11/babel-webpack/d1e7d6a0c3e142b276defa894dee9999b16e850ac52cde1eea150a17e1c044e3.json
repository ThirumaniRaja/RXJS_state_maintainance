{"ast":null,"code":"import { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function timeoutWith(due, withObservable, scheduler = async) {\n  return source => {\n    let absoluteTimeout = isDate(due);\n    let waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n  };\n}\nclass TimeoutWithOperator {\n  constructor(waitFor, absoluteTimeout, withObservable, scheduler) {\n    this.waitFor = waitFor;\n    this.absoluteTimeout = absoluteTimeout;\n    this.withObservable = withObservable;\n    this.scheduler = scheduler;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n  }\n}\nclass TimeoutWithSubscriber extends SimpleOuterSubscriber {\n  constructor(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n    super(destination);\n    this.absoluteTimeout = absoluteTimeout;\n    this.waitFor = waitFor;\n    this.withObservable = withObservable;\n    this.scheduler = scheduler;\n    this.scheduleTimeout();\n  }\n  static dispatchTimeout(subscriber) {\n    const {\n      withObservable\n    } = subscriber;\n    subscriber._unsubscribeAndRecycle();\n    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));\n  }\n  scheduleTimeout() {\n    const {\n      action\n    } = this;\n    if (action) {\n      this.action = action.schedule(this, this.waitFor);\n    } else {\n      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n    }\n  }\n  _next(value) {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n    super._next(value);\n  }\n  _unsubscribe() {\n    this.action = undefined;\n    this.scheduler = null;\n    this.withObservable = null;\n  }\n}","map":{"version":3,"names":["async","isDate","SimpleOuterSubscriber","innerSubscribe","SimpleInnerSubscriber","timeoutWith","due","withObservable","scheduler","source","absoluteTimeout","waitFor","now","Math","abs","lift","TimeoutWithOperator","constructor","call","subscriber","subscribe","TimeoutWithSubscriber","destination","scheduleTimeout","dispatchTimeout","_unsubscribeAndRecycle","add","action","schedule","_next","value","_unsubscribe","undefined"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\timeoutWith.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { isDate } from '../util/isDate';\nimport { ObservableInput, OperatorFunction, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function timeoutWith<T, R>(due: number | Date, withObservable: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n/* tslint:enable:max-line-length */\n\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * ![](timeoutWith.png)\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * ## Example\n * Add fallback observable\n * ```ts\n * import { interval } from 'rxjs';\n * import { timeoutWith } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n * const minutes = interval(60 * 1000);\n *\n * seconds.pipe(timeoutWith(900, minutes))\n *   .subscribe(\n *     value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                  // since first value of `seconds` will not arrive fast enough.\n *     err => console.log(err),     // Would be called after 900ms in case of `timeout`,\n *                                  // but here will never be called.\n *   );\n * ```\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {SchedulerLike} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\nexport function timeoutWith<T, R>(due: number | Date,\n                                  withObservable: ObservableInput<R>,\n                                  scheduler: SchedulerLike = async): OperatorFunction<T, T | R> {\n  return (source: Observable<T>) => {\n    let absoluteTimeout = isDate(due);\n    let waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(<number>due);\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n  };\n}\n\nclass TimeoutWithOperator<T> implements Operator<T, T> {\n  constructor(private waitFor: number,\n              private absoluteTimeout: boolean,\n              private withObservable: ObservableInput<any>,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TimeoutWithSubscriber(\n      subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TimeoutWithSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n\n  private action?: SchedulerAction<TimeoutWithSubscriber<T, R>>;\n\n  constructor(destination: Subscriber<T>,\n              private absoluteTimeout: boolean,\n              private waitFor: number,\n              private withObservable: ObservableInput<any>,\n              private scheduler: SchedulerLike) {\n    super(destination);\n    this.scheduleTimeout();\n  }\n\n  private static dispatchTimeout<T, R>(subscriber: TimeoutWithSubscriber<T, R>): void {\n    const { withObservable } = subscriber;\n    subscriber._unsubscribeAndRecycle();\n    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));\n  }\n\n  private scheduleTimeout(): void {\n    const { action } = this;\n    if (action) {\n      // Recycle the action if we've already scheduled one. All the production\n      // Scheduler Actions mutate their state/delay time and return themeselves.\n      // VirtualActions are immutable, so they create and return a clone. In this\n      // case, we need to set the action reference to the most recent VirtualAction,\n      // to ensure that's the one we clone from next time.\n      this.action = (<SchedulerAction<TimeoutWithSubscriber<T, R>>> action.schedule(this, this.waitFor));\n    } else {\n      this.add(this.action = (<SchedulerAction<TimeoutWithSubscriber<T, R>>> this.scheduler.schedule<TimeoutWithSubscriber<T, R>>(\n        TimeoutWithSubscriber.dispatchTimeout as any, this.waitFor, this\n      )));\n    }\n  }\n\n  protected _next(value: T): void {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n    super._next(value);\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.action = undefined;\n    this.scheduler = null!;\n    this.withObservable = null!;\n  }\n}\n"],"mappings":"AAEA,SAASA,KAAK,QAAQ,oBAAoB;AAE1C,SAASC,MAAM,QAAQ,gBAAgB;AAEvC,SAASC,qBAAqB,EAAEC,cAAc,EAAEC,qBAAqB,QAAQ,mBAAmB;AA2DhG,OAAM,SAAUC,WAAWA,CAAOC,GAAkB,EAClBC,cAAkC,EAClCC,SAAA,GAA2BR,KAAK;EAChE,OAAQS,MAAqB,IAAI;IAC/B,IAAIC,eAAe,GAAGT,MAAM,CAACK,GAAG,CAAC;IACjC,IAAIK,OAAO,GAAGD,eAAe,GAAI,CAACJ,GAAG,GAAGE,SAAS,CAACI,GAAG,EAAE,GAAIC,IAAI,CAACC,GAAG,CAASR,GAAG,CAAC;IAChF,OAAOG,MAAM,CAACM,IAAI,CAAC,IAAIC,mBAAmB,CAACL,OAAO,EAAED,eAAe,EAAEH,cAAc,EAAEC,SAAS,CAAC,CAAC;EAClG,CAAC;AACH;AAEA,MAAMQ,mBAAmB;EACvBC,YAAoBN,OAAe,EACfD,eAAwB,EACxBH,cAAoC,EACpCC,SAAwB;IAHxB,KAAAG,OAAO,GAAPA,OAAO;IACP,KAAAD,eAAe,GAAfA,eAAe;IACf,KAAAH,cAAc,GAAdA,cAAc;IACd,KAAAC,SAAS,GAATA,SAAS;EAC7B;EAEAU,IAAIA,CAACC,UAAyB,EAAEV,MAAW;IACzC,OAAOA,MAAM,CAACW,SAAS,CAAC,IAAIC,qBAAqB,CAC/CF,UAAU,EAAE,IAAI,CAACT,eAAe,EAAE,IAAI,CAACC,OAAO,EAAE,IAAI,CAACJ,cAAc,EAAE,IAAI,CAACC,SAAS,CACpF,CAAC;EACJ;;AAQF,MAAMa,qBAA4B,SAAQnB,qBAA2B;EAInEe,YAAYK,WAA0B,EAClBZ,eAAwB,EACxBC,OAAe,EACfJ,cAAoC,EACpCC,SAAwB;IAC1C,KAAK,CAACc,WAAW,CAAC;IAJA,KAAAZ,eAAe,GAAfA,eAAe;IACf,KAAAC,OAAO,GAAPA,OAAO;IACP,KAAAJ,cAAc,GAAdA,cAAc;IACd,KAAAC,SAAS,GAATA,SAAS;IAE3B,IAAI,CAACe,eAAe,EAAE;EACxB;EAEQ,OAAOC,eAAeA,CAAOL,UAAuC;IAC1E,MAAM;MAAEZ;IAAc,CAAE,GAAGY,UAAU;IACrCA,UAAU,CAACM,sBAAsB,EAAE;IACnCN,UAAU,CAACO,GAAG,CAACvB,cAAc,CAACI,cAAc,EAAE,IAAIH,qBAAqB,CAACe,UAAU,CAAC,CAAC,CAAC;EACvF;EAEQI,eAAeA,CAAA;IACrB,MAAM;MAAEI;IAAM,CAAE,GAAG,IAAI;IACvB,IAAIA,MAAM,EAAE;MAMV,IAAI,CAACA,MAAM,GAAmDA,MAAM,CAACC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAACjB,OAAO,CAAE;KACnG,MAAM;MACL,IAAI,CAACe,GAAG,CAAC,IAAI,CAACC,MAAM,GAAmD,IAAI,CAACnB,SAAS,CAACoB,QAAQ,CAC5FP,qBAAqB,CAACG,eAAsB,EAAE,IAAI,CAACb,OAAO,EAAE,IAAI,CAChE,CAAC;;EAEP;EAEUkB,KAAKA,CAACC,KAAQ;IACtB,IAAI,CAAC,IAAI,CAACpB,eAAe,EAAE;MACzB,IAAI,CAACa,eAAe,EAAE;;IAExB,KAAK,CAACM,KAAK,CAACC,KAAK,CAAC;EACpB;EAGAC,YAAYA,CAAA;IACV,IAAI,CAACJ,MAAM,GAAGK,SAAS;IACvB,IAAI,CAACxB,SAAS,GAAG,IAAK;IACtB,IAAI,CAACD,cAAc,GAAG,IAAK;EAC7B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}