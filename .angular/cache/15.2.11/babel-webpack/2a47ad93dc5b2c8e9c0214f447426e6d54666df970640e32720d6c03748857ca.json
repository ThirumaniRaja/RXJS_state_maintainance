{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nexport function scan(accumulator, seed) {\n  let hasSeed = false;\n  if (arguments.length >= 2) {\n    hasSeed = true;\n  }\n  return function scanOperatorFunction(source) {\n    return source.lift(new ScanOperator(accumulator, seed, hasSeed));\n  };\n}\nclass ScanOperator {\n  constructor(accumulator, seed, hasSeed = false) {\n    this.accumulator = accumulator;\n    this.seed = seed;\n    this.hasSeed = hasSeed;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n  }\n}\nclass ScanSubscriber extends Subscriber {\n  constructor(destination, accumulator, _seed, hasSeed) {\n    super(destination);\n    this.accumulator = accumulator;\n    this._seed = _seed;\n    this.hasSeed = hasSeed;\n    this.index = 0;\n  }\n  get seed() {\n    return this._seed;\n  }\n  set seed(value) {\n    this.hasSeed = true;\n    this._seed = value;\n  }\n  _next(value) {\n    if (!this.hasSeed) {\n      this.seed = value;\n      this.destination.next(value);\n    } else {\n      return this._tryNext(value);\n    }\n  }\n  _tryNext(value) {\n    const index = this.index++;\n    let result;\n    try {\n      result = this.accumulator(this.seed, value, index);\n    } catch (err) {\n      this.destination.error(err);\n    }\n    this.seed = result;\n    this.destination.next(result);\n  }\n}","map":{"version":3,"names":["Subscriber","scan","accumulator","seed","hasSeed","arguments","length","scanOperatorFunction","source","lift","ScanOperator","constructor","call","subscriber","subscribe","ScanSubscriber","destination","_seed","index","value","_next","next","_tryNext","result","err","error"],"sources":["C:\\Thiru\\Angular\\RXJS_state_maintainance\\app\\node_modules\\rxjs\\src\\internal\\operators\\scan.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed: R): OperatorFunction<T, R>;\nexport function scan<T>(accumulator: (acc: T, value: T, index: number) => T, seed?: T): MonoTypeOperatorFunction<T>;\nexport function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * ![](scan.png)\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * ## Example\n * Count the number of click events\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { scan, mapTo } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const ones = clicks.pipe(mapTo(1));\n * const seed = 0;\n * const count = ones.pipe(scan((acc, one) => acc + one, seed));\n * count.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nexport function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed?: T | R): OperatorFunction<T, R> {\n  let hasSeed = false;\n  // providing a seed of `undefined` *should* be valid and trigger\n  // hasSeed! so don't use `seed !== undefined` checks!\n  // For this reason, we have to check it here at the original call site\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\n  // means they didn't provide anything or if they literally provided `undefined`\n  if (arguments.length >= 2) {\n    hasSeed = true;\n  }\n\n  return function scanOperatorFunction(source: Observable<T>): Observable<R> {\n    return source.lift(new ScanOperator(accumulator, seed, hasSeed));\n  };\n}\n\nclass ScanOperator<T, R> implements Operator<T, R> {\n  constructor(private accumulator: (acc: R, value: T, index: number) => R, private seed?: T | R, private hasSeed: boolean = false) {}\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ScanSubscriber<T, R> extends Subscriber<T> {\n  private index: number = 0;\n\n  get seed(): T | R {\n    return this._seed;\n  }\n\n  set seed(value: T | R) {\n    this.hasSeed = true;\n    this._seed = value;\n  }\n\n  constructor(destination: Subscriber<R>, private accumulator: (acc: R, value: T, index: number) => R, private _seed: T | R,\n              private hasSeed: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSeed) {\n      this.seed = value;\n      this.destination.next(value);\n    } else {\n      return this._tryNext(value);\n    }\n  }\n\n  private _tryNext(value: T): void {\n    const index = this.index++;\n    let result: any;\n    try {\n      result = this.accumulator(<R>this.seed, value, index);\n    } catch (err) {\n      this.destination.error(err);\n    }\n    this.seed = result;\n    this.destination.next(result);\n  }\n}\n"],"mappings":"AAEA,SAASA,UAAU,QAAQ,eAAe;AAoD1C,OAAM,SAAUC,IAAIA,CAAOC,WAAmD,EAAEC,IAAY;EAC1F,IAAIC,OAAO,GAAG,KAAK;EAMnB,IAAIC,SAAS,CAACC,MAAM,IAAI,CAAC,EAAE;IACzBF,OAAO,GAAG,IAAI;;EAGhB,OAAO,SAASG,oBAAoBA,CAACC,MAAqB;IACxD,OAAOA,MAAM,CAACC,IAAI,CAAC,IAAIC,YAAY,CAACR,WAAW,EAAEC,IAAI,EAAEC,OAAO,CAAC,CAAC;EAClE,CAAC;AACH;AAEA,MAAMM,YAAY;EAChBC,YAAoBT,WAAmD,EAAUC,IAAY,EAAUC,OAAA,GAAmB,KAAK;IAA3G,KAAAF,WAAW,GAAXA,WAAW;IAAkD,KAAAC,IAAI,GAAJA,IAAI;IAAkB,KAAAC,OAAO,GAAPA,OAAO;EAAoB;EAElIQ,IAAIA,CAACC,UAAyB,EAAEL,MAAW;IACzC,OAAOA,MAAM,CAACM,SAAS,CAAC,IAAIC,cAAc,CAACF,UAAU,EAAE,IAAI,CAACX,WAAW,EAAE,IAAI,CAACC,IAAI,EAAE,IAAI,CAACC,OAAO,CAAC,CAAC;EACpG;;AAQF,MAAMW,cAAqB,SAAQf,UAAa;EAY9CW,YAAYK,WAA0B,EAAUd,WAAmD,EAAUe,KAAY,EACrGb,OAAgB;IAClC,KAAK,CAACY,WAAW,CAAC;IAF4B,KAAAd,WAAW,GAAXA,WAAW;IAAkD,KAAAe,KAAK,GAALA,KAAK;IAC9F,KAAAb,OAAO,GAAPA,OAAO;IAZnB,KAAAc,KAAK,GAAW,CAAC;EAczB;EAZA,IAAIf,IAAIA,CAAA;IACN,OAAO,IAAI,CAACc,KAAK;EACnB;EAEA,IAAId,IAAIA,CAACgB,KAAY;IACnB,IAAI,CAACf,OAAO,GAAG,IAAI;IACnB,IAAI,CAACa,KAAK,GAAGE,KAAK;EACpB;EAOUC,KAAKA,CAACD,KAAQ;IACtB,IAAI,CAAC,IAAI,CAACf,OAAO,EAAE;MACjB,IAAI,CAACD,IAAI,GAAGgB,KAAK;MACjB,IAAI,CAACH,WAAW,CAACK,IAAI,CAACF,KAAK,CAAC;KAC7B,MAAM;MACL,OAAO,IAAI,CAACG,QAAQ,CAACH,KAAK,CAAC;;EAE/B;EAEQG,QAAQA,CAACH,KAAQ;IACvB,MAAMD,KAAK,GAAG,IAAI,CAACA,KAAK,EAAE;IAC1B,IAAIK,MAAW;IACf,IAAI;MACFA,MAAM,GAAG,IAAI,CAACrB,WAAW,CAAI,IAAI,CAACC,IAAI,EAAEgB,KAAK,EAAED,KAAK,CAAC;KACtD,CAAC,OAAOM,GAAG,EAAE;MACZ,IAAI,CAACR,WAAW,CAACS,KAAK,CAACD,GAAG,CAAC;;IAE7B,IAAI,CAACrB,IAAI,GAAGoB,MAAM;IAClB,IAAI,CAACP,WAAW,CAACK,IAAI,CAACE,MAAM,CAAC;EAC/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}